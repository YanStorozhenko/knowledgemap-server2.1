[
  {
    "title": "Програмування як процес",
    "description": "Створення послідовностей інструкцій для керування комп’ютером"
  },
  {
    "title": "Поняття алгоритму",
    "description": "Алгоритм — це точна послідовність дій для досягнення результату"
  },
  {
    "title": "Команда виконавця",
    "description": "Одиниця дії, яку здатен виконати виконавець алгоритму"
  },
  {
    "title": "Поняття мови програмування",
    "description": "Формальна мова для запису алгоритмів і керування комп’ютером"
  },
  {
    "title": "Види мов програмування",
    "description": "Машинні, асемблерні, високорівневі мови програмування"
  },
  {
    "title": "Поняття змінної",
    "description": "Іменована область памʼяті для зберігання значення"
  },
  {
    "title": "Оголошення змінної",
    "description": "Процес створення змінної з вказаним типом"
  },
  {
    "title": "Ініціалізація змінної",
    "description": "Надання початкового значення змінній"
  },
  {
    "title": "Присвоєння значення",
    "description": "Операція надання нового значення існуючій змінній"
  },
  {
    "title": "Поняття константи",
    "description": "Змінна, значення якої не змінюється після ініціалізації"
  },
  {
    "title": "Тип int",
    "description": "Цілі числа зі знаком (наприклад, -10, 0, 25)"
  },
  {
    "title": "Тип double",
    "description": "Дійсні числа з плаваючою крапкою"
  },
  {
    "title": "Тип bool",
    "description": "Логічний тип, який може мати лише два значення: true або false"
  },
  {
    "title": "Тип char",
    "description": "Тип для зберігання одного символу"
  },
  {
    "title": "Тип string",
    "description": "Тип для зберігання рядка тексту"
  },
  {
    "title": "Оперативна памʼять",
    "description": "Місце тимчасового зберігання даних під час виконання програм"
  },
  {
    "title": "Стек памʼяті",
    "description": "Область памʼяті для автоматичних змінних і викликів методів"
  },
  {
    "title": "Купа памʼяті",
    "description": "Область памʼяті для динамічно створених обʼєктів"
  },
  {
    "title": "Масив як структура даних",
    "description": "Послідовність фіксованої кількості однотипних елементів"
  },
  {
    "title": "Список як структура даних",
    "description": "Колекція динамічного розміру, що підтримує додавання і видалення"
  },
  {
    "title": "Стек як структура даних",
    "description": "LIFO — останній увійшов, перший вийшов"
  },
  {
    "title": "Черга як структура даних",
    "description": "FIFO — перший увійшов, перший вийшов"
  },
  {
    "title": "Словник як структура даних",
    "description": "Зберігання пар ключ-значення для швидкого пошуку"
  },
  {
    "title": "Множина як структура даних",
    "description": "Колекція унікальних елементів без повторень"
  },








  {
    "title": "Алгоритм як послідовність дій",
    "description": "Алгоритм — це скінченна послідовність кроків для досягнення мети"
  },
  {
    "title": "Властивості алгоритму",
    "description": "Дискретність, визначеність, результативність, масовість, скінченність"
  },
  {
    "title": "Лінійний алгоритм",
    "description": "Алгоритм, у якому дії виконуються одна за одною без розгалужень і повторень"
  },
  {
    "title": "Розгалужений алгоритм",
    "description": "Алгоритм, у якому виконання дій залежить від умови (if, else)"
  },
  {
    "title": "Циклічний алгоритм",
    "description": "Алгоритм, у якому певні дії повторюються (while, for)"
  },
  {
    "title": "Комбінований алгоритм",
    "description": "Алгоритм, який містить елементи лінійного, розгалуженого і циклічного"
  },
  {
    "title": "Рекурсивний алгоритм",
    "description": "Алгоритм, у якому функція викликає саму себе"
  },
  {
    "title": "Ітеративний алгоритм",
    "description": "Алгоритм, що досягає результату через послідовне повторення обчислень"
  },
  {
    "title": "Детермінований алгоритм",
    "description": "Алгоритм, у якому на кожному кроці лише один можливий наступний крок"
  },
  {
    "title": "Недетермінований алгоритм",
    "description": "Алгоритм, що допускає вибір між кількома діями на одному кроці"
  },
  {
    "title": "Жадібний алгоритм",
    "description": "Алгоритм, що приймає локально оптимальні рішення на кожному кроці"
  },
  {
    "title": "Розділяй і володарюй",
    "description": "Алгоритм, що ділить задачу на підзадачі, розв’язує їх окремо і об'єднує результат"
  },
  {
    "title": "Динамічне програмування",
    "description": "Метод розв’язання задач шляхом збереження результатів підзадач"
  },
  {
    "title": "Життєвий цикл алгоритму",
    "description": "Аналіз задачі → Побудова алгоритму → Тестування → Реалізація"
  },




  {
    "title": "Умова в алгоритмах",
    "description": "Це логічне твердження, яке визначає, чи виконувати певну дію"
  },
  {
    "title": "Оператор if",
    "description": "Умовна конструкція, яка виконує блок коду, якщо умова істинна"
  },
  {
    "title": "Оператор else",
    "description": "Виконує альтернативний блок коду, якщо умова в if хибна"
  },
  {
    "title": "Оператор else if",
    "description": "Дозволяє перевірити кілька умов послідовно"
  },
  {
    "title": "Вкладені умовні оператори",
    "description": "Конструкції if/else, розміщені всередині інших умов"
  },
  {
    "title": "Оператор switch",
    "description": "Конструкція для вибору дії залежно від значення змінної"
  },
  {
    "title": "Оператори порівняння",
    "description": "==, !=, >, <, >=, <= — використовуються для побудови умов"
  },
  {
    "title": "Булевий тип даних",
    "description": "Тип, що може набувати лише двох значень: true або false"
  },
  {
    "title": "Логічний оператор AND (&&)",
    "description": "Результат істинний, якщо обидві умови істинні"
  },
  {
    "title": "Логічний оператор OR (||)",
    "description": "Результат істинний, якщо хоча б одна умова істинна"
  },
  {
    "title": "Логічний оператор NOT (!)",
    "description": "Змінює значення умови на протилежне"
  },
  {
    "title": "Логічна імплікація",
    "description": "A → B — якщо A істинне, то і B має бути істинним"
  },
  {
    "title": "Логічна еквівалентність",
    "description": "A ⇔ B — істинно, якщо обидва значення однакові"
  },
  {
    "title": "Таблиця істинності",
    "description": "Визначає результат логічного виразу для всіх комбінацій істинності"
  },
  {
    "title": "Закони де Моргана",
    "description": "!(A && B) ⇔ !A || !B; !(A || B) ⇔ !A && !B"
  },
  {
    "title": "Складені логічні вирази",
    "description": "Комбінація умов із використанням логічних операторів"
  },
  {
    "title": "Пріоритет логічних операторів",
    "description": "NOT > AND > OR — визначає порядок обчислення"
  },
  {
    "title": "Розгалуження в алгоритмах",
    "description": "Алгоритмічна конструкція, що змінює хід виконання залежно від умови"
  },
  {
    "title": "Булева алгебра в програмуванні",
    "description": "Формальна система для роботи з логічними значеннями в умовах"
  },



  {
    "title": "Побітові оператори",
    "description": "Оператори, що працюють із двійковим представленням чисел"
  },
  {
    "title": "Побітовий AND (&)",
    "description": "Повертає 1, якщо обидва біти — 1"
  },
  {
    "title": "Побітовий OR (|)",
    "description": "Повертає 1, якщо хоча б один з бітів — 1"
  },
  {
    "title": "Побітовий XOR (^)",
    "description": "Повертає 1, якщо біти відрізняються"
  },
  {
    "title": "Побітовий NOT (~)",
    "description": "Інвертує кожен біт (1 → 0, 0 → 1)"
  },
  {
    "title": "Зсув вліво (<<)",
    "description": "Зсуває біти вліво, еквівалент множенню на 2"
  },
  {
    "title": "Зсув вправо (>>)",
    "description": "Зсуває біти вправо, еквівалент діленню на 2"
  },
  {
    "title": "Маскування бітів",
    "description": "Використання побітових операцій для фільтрації окремих бітів"
  },
  {
    "title": "Встановлення біта",
    "description": "Використання OR для встановлення певного біта в 1"
  },
  {
    "title": "Скидання біта",
    "description": "Використання AND з інверсією для обнулення біта"
  },
  {
    "title": "Перевірка біта",
    "description": "Використання AND для перевірки, чи встановлений певний біт"
  },



  {
    "title": "Поняття циклу",
    "description": "Цикл — це конструкція для багаторазового виконання блоку коду"
  },
  {
    "title": "Умова циклу",
    "description": "Логічний вираз, який визначає, чи буде продовжено виконання циклу"
  },
  {
    "title": "Цикл for",
    "description": "Цикл із лічильником, де заздалегідь відома кількість ітерацій"
  },
  {
    "title": "Цикл while",
    "description": "Цикл із передумовою — тіло виконується, поки умова істинна"
  },
  {
    "title": "Цикл do-while",
    "description": "Цикл із післяумовою — тіло виконується принаймні один раз"
  },
  {
    "title": "Цикл foreach",
    "description": "Цикл для проходження по колекції або масиву"
  },
  {
    "title": "Нескінченний цикл",
    "description": "Цикл, умова якого завжди істинна (while(true))"
  },
  {
    "title": "Вкладені цикли",
    "description": "Цикл, розміщений усередині іншого циклу"
  },
  {
    "title": "Керування циклом — break",
    "description": "Завершує виконання циклу достроково"
  },
  {
    "title": "Керування циклом — continue",
    "description": "Пропускає поточну ітерацію та переходить до наступної"
  },
  {
    "title": "Індекс циклу",
    "description": "Змінна, яка використовується як лічильник у циклі"
  },
  {
    "title": "Типові помилки в циклах",
    "description": "Забута інкрементація, неправильна умова, нескінченність"
  },
  {
    "title": "Перебір масиву циклом for",
    "description": "Класичний спосіб обійти елементи масиву за індексом"
  },
  {
    "title": "Перебір колекції циклом foreach",
    "description": "Зручна конструкція для читання всіх елементів колекції"
  },
  {
    "title": "Цикл з кроком іншим, ніж 1",
    "description": "Можна змінити крок інкрементації: i += 2"
  },
  {
    "title": "Цикл із зменшенням лічильника",
    "description": "Цикл із зворотним напрямом: for (int i = n; i >= 0; i--)"
  },




  {
    "title": "Поняття рекурсії",
    "description": "Рекурсія — це виклик функцією самої себе"
  },
  {
    "title": "Рекурсивна функція",
    "description": "Функція, яка містить у тілі виклик себе самої"
  },
  {
    "title": "Базовий випадок рекурсії",
    "description": "Умова, яка зупиняє подальші виклики функції"
  },
  {
    "title": "Рекурсивний випадок",
    "description": "Частина функції, де відбувається рекурсивний виклик"
  },
  {
    "title": "Нескінченна рекурсія",
    "description": "Виникає, коли відсутній або недосяжний базовий випадок"
  },
  {
    "title": "Стек викликів при рекурсії",
    "description": "Кожен виклик функції зберігається в памʼяті до завершення"
  },
  {
    "title": "Факторіал як приклад рекурсії",
    "description": "Класичний приклад: n! = n * (n-1)!"
  },
  {
    "title": "Фібоначчі як приклад рекурсії",
    "description": "fib(n) = fib(n-1) + fib(n-2), приклад подвійної рекурсії"
  },
  {
    "title": "Переваги рекурсії",
    "description": "Код стає коротшим і зрозумілішим для задач зі вкладеною природою"
  },
  {
    "title": "Недоліки рекурсії",
    "description": "Велике споживання памʼяті, ризик переповнення стеку"
  },
  {
    "title": "Рекурсія проти ітерації",
    "description": "Рекурсивні алгоритми можуть бути переписані з використанням циклів"
  },
  {
    "title": "Хвостова рекурсія",
    "description": "Рекурсія, де результат обчислюється безпосередньо після виклику"
  },
  {
    "title": "Оптимізація рекурсії",
    "description": "Заміна рекурсії на ітерацію або використання мемоізації"
  },
  {
    "title": "Задачі, що природно розвʼязуються рекурсією",
    "description": "Дерева, пошук, обходи, математичні формули"
  },





  {
    "title": "Поняття масиву",
    "description": "Масив — це впорядкована колекція елементів одного типу"
  },
  {
    "title": "Індекс масиву",
    "description": "Позиція елемента в масиві, що починається з нуля"
  },
  {
    "title": "Оголошення масиву",
    "description": "Створення змінної-масиву певного типу, наприклад: int[] numbers"
  },
  {
    "title": "Ініціалізація масиву",
    "description": "Надання початкових значень масиву під час створення"
  },
  {
    "title": "Доступ до елемента масиву",
    "description": "Отримання або зміна значення за індексом, наприклад: arr[2]"
  },
  {
    "title": "Зміна елемента масиву",
    "description": "Присвоєння нового значення конкретному елементу масиву"
  },
  {
    "title": "Довжина масиву",
    "description": "Кількість елементів у масиві, отримується через властивість Length"
  },
  {
    "title": "Прохід масиву через for",
    "description": "Стандартний спосіб обійти всі елементи за індексом"
  },
  {
    "title": "Прохід масиву через foreach",
    "description": "Цикл для зручного читання елементів без індексів"
  },
  {
    "title": "Масиви як параметри методу",
    "description": "Передача масиву в метод для обробки в середині нього"
  },
  {
    "title": "Масиви як результат методу",
    "description": "Метод може повертати масив значень"
  },
  {
    "title": "Масив рядків",
    "description": "Масив, що зберігає рядкові значення типу string[]"
  },
  {
    "title": "Масив булевих значень",
    "description": "Може використовуватись для зберігання станів true/false"
  },
  {
    "title": "Багатовимірний масив",
    "description": "Масив з кількома вимірами, наприклад матриця: int[,] matrix"
  },
  {
    "title": "Ступінчастий масив (jagged)",
    "description": "Масив масивів: int[][] jagged = new int[3][]"
  },
  {
    "title": "Копіювання масиву",
    "description": "Створення нового масиву з таким самим вмістом"
  },
  {
    "title": "Сортування масиву",
    "description": "Використання Array.Sort() для впорядкування елементів"
  },
  {
    "title": "Пошук в масиві",
    "description": "Використання циклів або Array.IndexOf() для знаходження елементів"
  },
  {
    "title": "Масиви та памʼять",
    "description": "Масив — це об'єкт у купі з фіксованим розміром"
  },

  {
    "title": "Масив у памʼяті",
    "description": "Масив зберігається як послідовна область в оперативній памʼяті"
  },
  {
    "title": "Посилання на масив",
    "description": "Змінна масиву містить посилання на область памʼяті з даними"
  },
  {
    "title": "Розмір масиву в памʼяті",
    "description": "Залежить від кількості елементів і розміру кожного елемента"
  },
  {
    "title": "Багатовимірний масив",
    "description": "Масив із кількома індексами, наприклад: int[3,4]"
  },
  {
    "title": "Зберігання багатовимірного масиву",
    "description": "Зберігається як єдина таблиця в памʼяті з лінійною адресацією"
  },
  {
    "title": "Індексація в багатовимірному масиві",
    "description": "Кожен елемент доступний через набір індексів: arr[i, j]"
  },
  {
    "title": "Ступінчастий масив (рваний масив)",
    "description": "Масив, у якому кожен елемент є окремим одновимірним масивом"
  },
  {
    "title": "Оголошення ступінчастого масиву",
    "description": "Наприклад: int[][] jagged = new int[3][];"
  },
  {
    "title": "Різниця між рваним і багатовимірним масивом",
    "description": "Рваний зберігає посилання на масиви різної довжини, а багатовимірний — таблицю фіксованого розміру"
  },
  {
    "title": "Памʼять рваного масиву",
    "description": "Елементи зберігаються в різних ділянках памʼяті, кожна — окремий масив"
  },
  {
    "title": "Перетворення рваного масиву в звичайний",
    "description": "Можливе лише при однаковій довжині всіх вкладених масивів"
  },
  {
    "title": "Перетворення багатовимірного масиву на рваний",
    "description": "Створення масиву рядків із копіюванням значень по індексах"
  },
  {
    "title": "Прохід по багатовимірному масиву",
    "description": "Цикли з вкладеними індексами: for (int i=0; i<rows; i++)"
  },
  {
    "title": "Прохід по рваному масиву",
    "description": "foreach по зовнішньому масиву, потім foreach по внутрішньому"
  },


  {
    "title": "Поняття адреси в памʼяті",
    "description": "Кожна змінна в оперативній памʼяті має власну адресу — числове значення"
  },
  {
    "title": "Адресна памʼять",
    "description": "Памʼять, у якій кожна комірка має унікальний номер (адресу)"
  },
  {
    "title": "Покажчик (pointer)",
    "description": "Змінна, яка містить адресу іншої змінної або обʼєкта в памʼяті"
  },
  {
    "title": "Непряме звернення",
    "description": "Отримання доступу до даних за допомогою покажчика"
  },
  {
    "title": "Оператор dereference (*)",
    "description": "Доступ до значення за адресою, що зберігається в покажчику"
  },
  {
    "title": "Оператор address-of (&)",
    "description": "Отримання адреси змінної для збереження її в покажчику"
  },
  {
    "title": "Покажчики в C#",
    "description": "Доступні лише в unsafe-блоках, використовуються рідко"
  },
  {
    "title": "Стекова памʼять",
    "description": "Область памʼяті для зберігання локальних змінних і викликів функцій"
  },
  {
    "title": "Купа (heap)",
    "description": "Область памʼяті для динамічно створених обʼєктів"
  },
  {
    "title": "Розміщення змінних у стеку",
    "description": "Примітиви та локальні змінні за замовчуванням зберігаються у стеку"
  },
  {
    "title": "Розміщення обʼєктів у купі",
    "description": "Обʼєкти створюються в купі й посилання на них зберігаються у стеку"
  },
  {
    "title": "Garbage Collector",
    "description": "Служба .NET, що автоматично очищує памʼять від невикористаних обʼєктів"
  },
  {
    "title": "Мануальне керування памʼяттю",
    "description": "Підхід, де програміст сам виділяє і звільняє памʼять (у C/C++)"
  },
  {
    "title": "Памʼять і посилання в C#",
    "description": "Змінні-обʼєкти зберігають не самі дані, а посилання на них у купі"
  },
  {
    "title": "Null reference",
    "description": "Посилання, яке не вказує на жоден обʼєкт (default)"
  },
  {
    "title": "Витік памʼяті (memory leak)",
    "description": "Ситуація, коли виділена памʼять не звільняється й не використовується"
  },
  {
    "title": "Фрагментація памʼяті",
    "description": "Розбиття памʼяті на багато невеликих невикористаних блоків"
  },
  {
    "title": "Адресація в масивах",
    "description": "Елементи масиву зберігаються послідовно в памʼяті, адреси обчислюються"
  },
  {
    "title": "Покажчик на масив",
    "description": "Покажчик, що вказує на перший елемент масиву"
  },

  {
    "title": "Поняття структури",
    "description": "Структура — це тип значення, що обʼєднує кілька полів під одним імʼям"
  },
  {
    "title": "Відмінність struct від class",
    "description": "Struct — тип значення; class — тип посилання"
  },
  {
    "title": "Оголошення структури",
    "description": "Використовується ключове слово struct: struct Point { int x; int y; }"
  },
  {
    "title": "Ініціалізація структури",
    "description": "Можна ініціалізувати через конструктор або явно задати значення полів"
  },
  {
    "title": "Конструктор у структурі",
    "description": "Структура може мати конструктор, але без параметрів за замовчуванням"
  },
  {
    "title": "Властивості у struct",
    "description": "Структура може містити поля, властивості, методи"
  },
  {
    "title": "Struct як тип значення",
    "description": "Структура зберігається у стеку, копіюється при передаванні"
  },
  {
    "title": "Struct не може мати спадкоємців",
    "description": "Структури не підтримують наслідування, лише реалізацію інтерфейсів"
  },
  {
    "title": "Struct і інтерфейси",
    "description": "Структура може реалізовувати інтерфейси"
  },
  {
    "title": "Застосування структур",
    "description": "Використовуються для невеликих, незмінних типів, як-от координати, кольори"
  },
  {
    "title": "Struct і значення за замовчуванням",
    "description": "При створенні без ініціалізації поля мають нульові значення"
  },
  {
    "title": "Копіювання структур",
    "description": "Передача структури створює копію, а не посилання"
  },
  {
    "title": "Struct як параметр методу",
    "description": "Передається за значенням, копіюється при виклику"
  },
  {
    "title": "Struct як результат методу",
    "description": "Метод може повертати структуру як значення"
  },
  {
    "title": "Struct і null",
    "description": "Struct не може бути null, якщо явно не вказаний як Nullable"
  },


  {
    "title": "Тип даних",
    "description": "Тип визначає множину можливих значень змінної та допустимі операції над нею"
  },
  {
    "title": "Тип значення",
    "description": "Тип, змінні якого зберігають самі дані (int, double, bool, struct)"
  },
  {
    "title": "Тип посилання",
    "description": "Тип, змінні якого зберігають посилання на обʼєкти в купі (class, array, string)"
  },
  {
    "title": "Тип string",
    "description": "Посилальний тип, що поводиться як значення через іммутабельність"
  },
  {
    "title": "Тип object",
    "description": "Базовий тип для всіх типів у C#, включаючи значення і посилання"
  },
  {
    "title": "Тип dynamic",
    "description": "Тип, який визначається під час виконання, без перевірки компілятором"
  },
  {
    "title": "Тип var",
    "description": "Неявно типізована змінна, тип якої визначається на основі значення"
  },
  {
    "title": "Передача за значенням",
    "description": "Метод отримує копію значення, зміни не впливають на оригінал"
  },
  {
    "title": "Передача за посиланням",
    "description": "Метод працює з тією ж змінною, зміни впливають на оригінал"
  },
  {
    "title": "Модифікатор ref",
    "description": "Змінна передається в метод за посиланням, має бути ініціалізована"
  },
  {
    "title": "Модифікатор out",
    "description": "Змінна передається для заповнення в методі, не обов’язково ініціалізована"
  },
  {
    "title": "Модифікатор in",
    "description": "Змінна передається за посиланням, але лише для читання"
  },
  {
    "title": "Nullable типи",
    "description": "Типи значення, які можуть бути null: int?, bool?"
  },
  {
    "title": "Boxing",
    "description": "Перетворення значення типу в обʼєкт типу object (упаковка)"
  },
  {
    "title": "Unboxing",
    "description": "Повернення значення з обʼєкта до початкового типу (розпаковка)"
  },
  {
    "title": "Покажчики в C#",
    "description": "Доступні лише в unsafe-коді, дозволяють працювати з адресами"
  },
  {
    "title": "Масив як посилальний тип",
    "description": "Масиви завжди зберігаються в купі й передаються за посиланням"
  },
  {
    "title": "Struct як тип значення",
    "description": "Struct передається як копія, якщо не використано ref/out"
  },

  {
    "title": "Поняття функції (методу)",
    "description": "Функція — це іменований блок коду, який виконує певну дію"
  },
  {
    "title": "Оголошення функції",
    "description": "Формальне визначення функції з іменем, параметрами і типом повернення"
  },
  {
    "title": "Виклик функції",
    "description": "Ініціювання виконання функції з передачею аргументів"
  },
  {
    "title": "Параметри функції",
    "description": "Змінні, які приймають значення, передані при виклику функції"
  },
  {
    "title": "Аргументи функції",
    "description": "Значення, які передаються при виклику функції"
  },
  {
    "title": "Тип повернення функції",
    "description": "Тип значення, яке функція повертає після виконання"
  },
  {
    "title": "Функція без повернення (void)",
    "description": "Функція, яка виконує дію, але не повертає значення"
  },
  {
    "title": "Функція з поверненням значення",
    "description": "Функція, яка повертає значення через оператор return"
  },
  {
    "title": "Функція без параметрів",
    "description": "Функція, яка не приймає жодних вхідних значень"
  },
  {
    "title": "Функція з кількома параметрами",
    "description": "Функція, яка приймає два і більше значень на вхід"
  },
  {
    "title": "Функція з ref параметром",
    "description": "Параметр передається за посиланням, зміни впливають на оригінал"
  },
  {
    "title": "Функція з out параметром",
    "description": "Параметр використовується для повернення значення через аргумент"
  },
  {
    "title": "Функція з in параметром",
    "description": "Параметр передається за посиланням, але лише для читання"
  },
  {
    "title": "Перевантаження функцій",
    "description": "Можливість створювати кілька функцій з однаковим іменем, але різними параметрами"
  },
  {
    "title": "Рекурсивна функція",
    "description": "Функція, яка викликає сама себе"
  },
  {
    "title": "Локальна функція",
    "description": "Функція, оголошена всередині іншої функції"
  },
  {
    "title": "Функція з параметром за замовчуванням",
    "description": "Параметр, який має значення за замовчуванням і не обов’язковий при виклику"
  },
  {
    "title": "Функція з масивом параметрів (params)",
    "description": "Дозволяє передавати змінну кількість аргументів у вигляді масиву"
  },
  {
    "title": "Повернення масиву з функції",
    "description": "Функція може повертати масив як результат обчислень"
  },
  {
    "title": "Виклик функції з іншого класу",
    "description": "Використання імені класу або створення обʼєкта для доступу до методу"
  },


  {
    "title": "Зовнішнє збереження даних",
    "description": "Процес збереження інформації на диску або іншому носії"
  },
  {
    "title": "Що таке файл",
    "description": "Файл — це одиниця збереження інформації з унікальним іменем і типом"
  },
  {
    "title": "Розширення файлу",
    "description": "Суфікс у назві файлу, який вказує на його тип (.txt, .jpg, .exe)"
  },
  {
    "title": "Текстовий файл",
    "description": "Файл, який містить лише текстову інформацію, доступну для читання"
  },
  {
    "title": "Бінарний файл",
    "description": "Файл, що містить дані у двійковому представленні, нечитабельний напряму"
  },
  {
    "title": "Формат CSV",
    "description": "Формат текстового файлу, де значення розділені комами або іншими роздільниками"
  },
  {
    "title": "Формат JSON",
    "description": "Структурований формат зберігання даних у вигляді пар ключ-значення"
  },
  {
    "title": "Формат XML",
    "description": "Ієрархічний текстовий формат для опису структурованих даних"
  },
  {
    "title": "Формат INI",
    "description": "Текстовий файл конфігурації з параметрами, розділеними секціями"
  },
  {
    "title": "Графічні формати файлів",
    "description": "Файли, які містять зображення (JPEG, PNG, BMP, GIF, SVG)"
  },
  {
    "title": "Формат BMP",
    "description": "Bitmap — простий растровий графічний формат без стиснення"
  },
  {
    "title": "Особливості BMP",
    "description": "Містить заголовок, інформацію про пікселі, не підтримує прозорість, великі розміри"
  },
  {
    "title": "Формат PNG",
    "description": "Стиснений растровий формат із підтримкою прозорості та без втрат"
  },
  {
    "title": "Формат JPEG",
    "description": "Стиснення з втратами, підходить для фотографій, менший розмір"
  },
  {
    "title": "Формат GIF",
    "description": "Формат з обмеженою палітрою кольорів, підтримує анімацію"
  },
  {
    "title": "Формат SVG",
    "description": "Векторний графічний формат, описаний XML-структурою"
  },
  {
    "title": "Читання файлу в C#",
    "description": "Використання File.ReadAllText, File.ReadAllLines або StreamReader"
  },
  {
    "title": "Запис у файл у C#",
    "description": "File.WriteAllText, File.AppendAllText, або StreamWriter"
  },
  {
    "title": "Серійне збереження обʼєктів у JSON",
    "description": "Перетворення обʼєкта в текст для збереження у файлі"
  },
  {
    "title": "Десеріалізація JSON у C#",
    "description": "Відновлення обʼєкта з JSON-файлу за допомогою JsonSerializer"
  },
  {
    "title": "Обробка помилок при роботі з файлами",
    "description": "FileNotFoundException, IOException, перевірка існування файлу"
  },
  {
    "title": "Права доступу до файлу",
    "description": "Може бути заборонено читання або запис без відповідних прав"
  },
  {
    "title": "Файлова система",
    "description": "Організація файлів і папок на носії: FAT, NTFS, ext4"
  },
  {
    "title": "Абсолютний і відносний шлях до файлу",
    "description": "Повний шлях до файлу від кореня диска або шлях відносно програми"
  },
  {
    "title": "Використання using при роботі з файлами",
    "description": "Автоматичне закриття файлу після завершення роботи"
  },
  {
    "title": "Потік (Stream)",
    "description": "Абстракція для послідовного читання або запису даних"
  },
  {
    "title": "Види потоків у C#",
    "description": "FileStream, MemoryStream, NetworkStream, BufferedStream тощо"
  },
  {
    "title": "FileStream",
    "description": "Потік для читання/запису даних у файл"
  },
  {
    "title": "MemoryStream",
    "description": "Потік для роботи з даними, що зберігаються в памʼяті"
  },
  {
    "title": "BufferedStream",
    "description": "Обгортка, яка додає буферизацію до іншого потоку"
  },
  {
    "title": "StreamReader",
    "description": "Зручний клас для читання тексту з потоку"
  },
  {
    "title": "StreamWriter",
    "description": "Зручний клас для запису тексту в потік"
  },
  {
    "title": "BinaryReader",
    "description": "Клас для читання бінарних даних із потоку"
  },
  {
    "title": "BinaryWriter",
    "description": "Клас для запису бінарних даних у потік"
  },
  {
    "title": "Відкриття потоку",
    "description": "Створення обʼєкта потоку з вказаним джерелом (наприклад, шляхом до файлу)"
  },
  {
    "title": "Читання з потоку",
    "description": "Отримання даних з потоку через методи Read(), ReadLine(), ReadAsync()"
  },
  {
    "title": "Запис у потік",
    "description": "Додавання даних до потоку через Write(), WriteLine(), WriteAsync()"
  },
  {
    "title": "Закриття потоку",
    "description": "Метод Close() або using-блок для безпечного завершення"
  },
  {
    "title": "Буферизація в потоках",
    "description": "Тимчасове зберігання даних у памʼяті для зменшення кількості операцій введення/виведення"
  },
  {
    "title": "Асинхронна робота з потоками",
    "description": "Методи ReadAsync(), WriteAsync() для неблокуючої роботи"
  },
  {
    "title": "Потік як вхідний параметр",
    "description": "Метод, який приймає Stream і може працювати з будь-яким джерелом"
  },
  {
    "title": "Position і Seek",
    "description": "Керування поточним положенням у потоці"
  },
  {
    "title": "Flush у StreamWriter",
    "description": "Примусове записування буферизованих даних у потік"
  },
  {
    "title": "Read/Write байтами",
    "description": "Методи роботи з масивами байтів у бінарних потоках"
  },
  {
    "title": "Потоки і ресурси",
    "description": "Необхідність вручну або автоматично звільняти ресурси після використання"
  },




  {
    "title": "Введення даних користувачем",
    "description": "Отримання даних з клавіатури через Console.ReadLine()"
  },
  {
    "title": "Типове введення у C#",
    "description": "Введення рядка, числа або іншого типу через консоль"
  },
  {
    "title": "Перетворення введеного тексту в число",
    "description": "Використання int.Parse або Convert.ToInt32 для перетворення рядка"
  },
  {
    "title": "Безпечне введення числа",
    "description": "Використання int.TryParse для обробки помилок введення"
  },
  {
    "title": "Зчитування кількох значень з одного рядка",
    "description": "Поділ введеного рядка за допомогою Split()"
  },
  {
    "title": "Зчитування масиву чисел з рядка",
    "description": "Парсинг чисел через Split() і Select(int.Parse)"
  },
  {
    "title": "Виведення даних у консоль",
    "description": "Використання Console.Write() та Console.WriteLine()"
  },
  {
    "title": "Форматований вивід",
    "description": "Виведення змінних у шаблонах через інтерполяцію або string.Format()"
  },
  {
    "title": "Виведення чисел з фіксованою точністю",
    "description": "Форматування чисел: {x:F2} — два знаки після крапки"
  },
  {
    "title": "Виведення в таблицю",
    "description": "Вирівнювання тексту за шириною колонок через PadLeft() або табуляцію"
  },
  {
    "title": "Колір тексту в консолі",
    "description": "Використання Console.ForegroundColor та Console.BackgroundColor"
  },
  {
    "title": "Читання символів окремо",
    "description": "Console.Read() — зчитує один символ як int-код"
  },
  {
    "title": "Очистка консолі",
    "description": "Console.Clear() очищує весь вивід"
  },
  {
    "title": "Затримка перед закриттям",
    "description": "Console.ReadKey() — чекає на натискання клавіші перед виходом"
  },
  {
    "title": "Маскування введення (наприклад, паролі)",
    "description": "Використання Console.ReadKey(true) для приховування введення"
  },


  {
    "title": "Тип даних string",
    "description": "Тип для збереження послідовності символів у C#"
  },
  {
    "title": "Немінливість string",
    "description": "Рядки у C# є незмінними: будь-яка операція створює новий обʼєкт"
  },
  {
    "title": "Створення рядка",
    "description": "Оголошення рядка: string name = \"Привіт\""
  },
  {
    "title": "Конкатенація рядків",
    "description": "Обʼєднання рядків через + або string.Concat()"
  },
  {
    "title": "Інтерполяція рядків",
    "description": "Вставлення змінних у шаблон: $\"Привіт, {name}\""
  },
  {
    "title": "Порівняння рядків",
    "description": "string.Equals(), ==, StringComparison"
  },
  {
    "title": "Довжина рядка",
    "description": "Властивість string.Length повертає кількість символів"
  },
  {
    "title": "Доступ до символів у рядку",
    "description": "Індексація: name[0] повертає перший символ"
  },
  {
    "title": "Метод Substring()",
    "description": "Отримання підрядка зі string: name.Substring(2, 3)"
  },
  {
    "title": "Методи обробки рядків",
    "description": "ToUpper(), ToLower(), Trim(), Replace(), Split(), Contains() тощо"
  },
  {
    "title": "Метод Split()",
    "description": "Розділення рядка на частини за роздільником"
  },
  {
    "title": "Метод Join()",
    "description": "Обʼєднання масиву рядків в один рядок із роздільником"
  },
  {
    "title": "Перевірка вмісту",
    "description": "string.Contains(), StartsWith(), EndsWith()"
  },
  {
    "title": "Перетворення рядка в число",
    "description": "int.Parse(), int.TryParse() — перетворення тексту в int"
  },
  {
    "title": "Форматування рядків",
    "description": "string.Format(), {}, шаблонізовані рядки"
  },
  {
    "title": "Escape-послідовності",
    "description": "Наприклад: \"\\n\" — новий рядок, \"\\t\" — табуляція, \"\\\\\" — зворотна скісна риса"
  },
  {
    "title": "Рядки з декількома рядками",
    "description": "Використання \"@\"-рядків або потрійних лапок у нових версіях C#"
  },
  {
    "title": "StringBuilder",
    "description": "Клас для ефективної побудови рядків без створення нових обʼєктів"
  },
  {
    "title": "Конвертація символів",
    "description": "char.ToUpper(), char.IsDigit(), char.IsLetter()"
  },
  {
    "title": "Пошук у рядку",
    "description": "IndexOf(), LastIndexOf(), Contains()"
  },
  {
    "title": "Регулярні вирази",
    "description": "Використання Regex для пошуку та заміни шаблонів у рядках"
  },


  {
    "title": "Регулярні вирази",
    "description": "Шаблони для пошуку і обробки тексту за допомогою правил"
  },
  {
    "title": "Клас Regex у C#",
    "description": "System.Text.RegularExpressions.Regex — основний клас для роботи з регулярними виразами"
  },
  {
    "title": "Метод Regex.IsMatch",
    "description": "Перевірка, чи рядок відповідає шаблону"
  },
  {
    "title": "Метод Regex.Match",
    "description": "Повертає перше співпадіння з шаблоном у рядку"
  },
  {
    "title": "Метод Regex.Matches",
    "description": "Повертає всі співпадіння шаблону в рядку"
  },
  {
    "title": "Метод Regex.Replace",
    "description": "Заміна частини рядка, що відповідає шаблону"
  },
  {
    "title": "Метасимвол . (крапка)",
    "description": "Позначає будь-який символ, крім нового рядка"
  },
  {
    "title": "Квантифікатори *, +, ?",
    "description": "* — 0 або більше, + — 1 або більше, ? — 0 або 1 входжень"
  },
  {
    "title": "Фігурні дужки {n,m}",
    "description": "Визначення точної або межової кількості входжень: {2}, {1,3}"
  },
  {
    "title": "Класи символів [abc]",
    "description": "Будь-який із символів: a, b або c"
  },
  {
    "title": "Діапазони [a-z]",
    "description": "Будь-яка літера в зазначеному діапазоні"
  },
  {
    "title": "Інверсія класу символів [^0-9]",
    "description": "Будь-який символ, крім цифр"
  },
  {
    "title": "Префікси \\d, \\w, \\s",
    "description": "\\d — цифра, \\w — літера/цифра/_, \\s — пробіл"
  },
  {
    "title": "Якір ^ і $",
    "description": "^ — початок рядка, $ — кінець рядка"
  },
  {
    "title": "Групи ( ... )",
    "description": "Обʼєднання частин шаблону або збереження підрядків"
  },
  {
    "title": "Альтернація |",
    "description": "Оператор «або»: a|b відповідає або a, або b"
  },
  {
    "title": "Екранування спеціальних символів",
    "description": "Використання \\ перед метасимволом: \\. \\* \\+"
  },
  {
    "title": "Приклади використання",
    "description": "Перевірка email, телефону, номера паспорта тощо"
  },
  {
    "title": "RegexOptions",
    "description": "Параметри: IgnoreCase, Multiline, Compiled тощо"
  },


  {
    "title": "Система числення",
    "description": "Спосіб запису чисел за допомогою фіксованого набору цифр і основи (бази)"
  },
  {
    "title": "Десяткова система",
    "description": "Найпоширеніша система числення з основою 10"
  },
  {
    "title": "Двійкова система",
    "description": "Система числення з основою 2, використовується в комп’ютерах"
  },
  {
    "title": "Вісімкова система",
    "description": "Система числення з основою 8, використовується в UNIX"
  },
  {
    "title": "Шістнадцяткова система",
    "description": "Система числення з основою 16, зручна для представлення байтів (0–9, A–F)"
  },
  {
    "title": "Цифри в різних системах",
    "description": "Двійкова: 0-1, Вісімкова: 0-7, Шістнадцяткова: 0-9, A-F"
  },
  {
    "title": "Переведення з десяткової в двійкову",
    "description": "Ділення на 2 з записом остач"
  },
  {
    "title": "Переведення з двійкової в десяткову",
    "description": "Множення кожного біта на 2^позиція і додавання"
  },
  {
    "title": "Переведення з десяткової у шістнадцяткову",
    "description": "Ділення на 16 з остачею; остачі: 10=A, 11=B тощо"
  },
  {
    "title": "Переведення між будь-якими системами",
    "description": "Спочатку в десяткову, потім у потрібну"
  },
  {
    "title": "Вбудовані методи C# для переведення",
    "description": "Convert.ToString(value, base), Convert.ToInt32(string, base)"
  },
  {
    "title": "Представлення чисел у памʼяті",
    "description": "Компʼютер зберігає всі числа у двійковій формі"
  },
  {
    "title": "Застосування шістнадцяткової системи",
    "description": "Представлення кольору, адреси в памʼяті, байтів"
  },
  {
    "title": "Byte і біт",
    "description": "1 байт = 8 бітів, мінімальна одиниця зберігання в памʼяті"
  },
  {
    "title": "Побітові операції",
    "description": "Операції над двійковими числами: &, |, ^, ~, <<, >>"
  },
  {
    "title": "Двійковий код",
    "description": "Кодування чисел у вигляді послідовності 0 і 1"
  },
  {
    "title": "Поняття нуля в різних системах",
    "description": "У всіх системах числення 0 — це число без значення"
  },
  {
    "title": "Представлення від’ємних чисел",
    "description": "Додатковий код (two’s complement) для від’ємних чисел у двійковій системі"
  },
  {
    "title": "Реальні числа і округлення",
    "description": "Обмеження представлення чисел з плаваючою комою у бітовому вигляді"
  },



  {
    "title": "Арифметичні оператори",
    "description": "Оператори: + (додавання), - (віднімання), * (множення), / (ділення), % (остача від ділення)"
  },
  {
    "title": "Оператор % (остача)",
    "description": "Повертає остачу від ділення одного числа на інше"
  },
  {
    "title": "Ділення цілих чисел",
    "description": "У випадку int / int результат буде округлено до цілого вниз"
  },
  {
    "title": "Ділення з плаваючою крапкою",
    "description": "Якщо хоча б один операнд — float/double, ділення буде з десятковою частиною"
  },
  {
    "title": "Порядок виконання операцій",
    "description": "Спочатку *, /, %, потім +, -; дужки змінюють порядок"
  },
  {
    "title": "Використання дужок у виразах",
    "description": "Операції в дужках виконуються першими: (2 + 3) * 4 = 20"
  },
  {
    "title": "Інкремент і декремент",
    "description": "Оператори ++ і --; префіксна (до зміни) та постфіксна (після використання) форми"
  },
  {
    "title": "Комбіновані оператори +=, -=, *=, /=",
    "description": "Скорочені записи: x += 5 еквівалентно x = x + 5"
  },
  {
    "title": "Перетворення типів (casting)",
    "description": "Примусове приведення типів: (int)3.7 => 3"
  },
  {
    "title": "Автоматичне приведення типів",
    "description": "C# автоматично конвертує типи з меншого до більшого (наприклад, int → double)"
  },
  {
    "title": "Округлення чисел",
    "description": "Math.Round(), Math.Ceiling(), Math.Floor() для округлення чисел"
  },
  {
    "title": "Математичні функції",
    "description": "Math.Abs(), Math.Pow(), Math.Sqrt(), Math.Min(), Math.Max()"
  },
  {
    "title": "Ділення на нуль",
    "description": "При int / 0 — помилка; при double / 0 — результат Infinity або NaN"
  },
  {
    "title": "Порядок виконання при змішаних типах",
    "description": "int + double → результат double; пріоритет типів: int < long < float < double"
  },
  {
    "title": "Вирази з кількома операціями",
    "description": "Складні вирази комбінують багато операторів і потребують контролю пріоритету"
  },
  {
    "title": "Множення та переповнення",
    "description": "int може переповнитися: перевірка через checked або використання long"
  },
  {
    "title": "Math.DivRem()",
    "description": "Функція, що повертає частку й остачу одночасно"
  },
  {
    "title": "Округлення до n знаків",
    "description": "Math.Round(число, n) — округлення до n знаків після крапки"
  },




  {
    "title": "Обробка винятків у C#",
    "description": "Механізм виявлення та перехоплення помилок під час виконання програми"
  },
  {
    "title": "Блок try",
    "description": "Містить код, який може викликати виняток"
  },
  {
    "title": "Блок catch",
    "description": "Обробляє виняток, який виник у блоці try"
  },
  {
    "title": "Блок finally",
    "description": "Код, що виконується завжди — незалежно від того, чи стався виняток"
  },
  {
    "title": "Типи винятків",
    "description": "System.Exception, DivideByZeroException, ArgumentNullException, FormatException тощо"
  },
  {
    "title": "Кілька блоків catch",
    "description": "Можна мати кілька catch для різних типів помилок"
  },
  {
    "title": "catch без параметра",
    "description": "Універсальний catch перехоплює будь-який виняток"
  },
  {
    "title": "Властивості обʼєкта Exception",
    "description": "Message, StackTrace, InnerException — інформація про помилку"
  },
  {
    "title": "Викидання винятку вручну",
    "description": "Оператор throw для генерації винятку вручну"
  },
  {
    "title": "Оператор throw у catch",
    "description": "Повторна генерація винятку для передачі далі"
  },
  {
    "title": "finally для звільнення ресурсів",
    "description": "Наприклад, закриття файлу або зʼєднання з БД"
  },
  {
    "title": "Вкладені блоки try-catch",
    "description": "Можна вкладати try-catch усередині інших для детального контролю"
  },
  {
    "title": "Розробка власних винятків",
    "description": "Створення класів, що наслідують від Exception"
  },
  {
    "title": "Приклад: перетворення рядка в число",
    "description": "int.Parse() може викликати FormatException, який треба обробити"
  },
  {
    "title": "Логування винятків",
    "description": "Збереження інформації про помилки у файл або консоль"
  },
  {
    "title": "Небезпечні операції без try-catch",
    "description": "Код без обробки винятків може призвести до аварійного завершення програми"
  },



  {
    "title": "Типові джерела винятків",
    "description": "Неправильне введення, ділення на нуль, неправильний формат, звернення до null, помилки файлів"
  },
  {
    "title": "DivideByZeroException",
    "description": "Виникає при спробі ділення на нуль (тільки для цілих чисел)"
  },
  {
    "title": "FormatException",
    "description": "Спроба перетворити рядок у число або дату з неправильним форматом"
  },
  {
    "title": "NullReferenceException",
    "description": "Спроба доступу до члена об’єкта, що дорівнює null"
  },
  {
    "title": "IndexOutOfRangeException",
    "description": "Спроба доступу до елемента масиву або списку за неправильним індексом"
  },
  {
    "title": "ArgumentException",
    "description": "Методу передано неправильний аргумент"
  },
  {
    "title": "ArgumentNullException",
    "description": "Методу передано null, хоча очікувався обʼєкт"
  },
  {
    "title": "FileNotFoundException",
    "description": "Файл не знайдено під час спроби відкрити його"
  },
  {
    "title": "IOException",
    "description": "Загальна помилка вводу/виводу при роботі з файлами чи потоками"
  },
  {
    "title": "OverflowException",
    "description": "Результат арифметичної операції перевищує межі типу"
  },
  {
    "title": "InvalidCastException",
    "description": "Спроба некоректного приведення типів"
  },
  {
    "title": "OutOfMemoryException",
    "description": "Недостатньо памʼяті для виконання операції (рідко в основах)"
  },
  {
    "title": "StackOverflowException",
    "description": "Занадто глибока рекурсія (неможливо перехопити)"
  },
  {
    "title": "Exception — базовий тип",
    "description": "Можна перехопити всі помилки разом, але краще обробляти конкретні"
  },
  {
    "title": "Коли перехоплювати винятки",
    "description": "При взаємодії з користувачем, файлами, перетвореннями даних, роботою з масивами"
  },
  {
    "title": "Чого не варто робити в catch",
    "description": "Не ігнорувати винятки (порожній catch), не приховувати помилки"
  },





  {
    "title": "Перетворення типів (type conversion)",
    "description": "Зміна типу значення з одного типу даних на інший"
  },
  {
    "title": "Неявне перетворення (implicit cast)",
    "description": "Автоматичне перетворення типів з меншого в більший без втрати даних (наприклад, int → float)"
  },
  {
    "title": "Явне перетворення (explicit cast)",
    "description": "Примусове приведення типу з втратою точності або з потенційною помилкою (наприклад, double → int)"
  },
  {
    "title": "Оператор приведення (тип)значення",
    "description": "Синтаксис: (int)3.14 → 3"
  },
  {
    "title": "Convert.ToInt32(), ToDouble(), ToString()",
    "description": "Методи класу Convert для перетворення між базовими типами"
  },
  {
    "title": "int.Parse()",
    "description": "Перетворення рядка у число; викликає FormatException при неправильному форматі"
  },
  {
    "title": "int.TryParse()",
    "description": "Безпечне перетворення рядка в число; повертає true/false"
  },
  {
    "title": "Boxing",
    "description": "Неявне перетворення значимого типу (value type) у посилальний тип (object)"
  },
  {
    "title": "Unboxing",
    "description": "Явне перетворення з object назад у значимий тип"
  },
  {
    "title": "as і is оператори",
    "description": "Перевірка або приведення до посилального типу: x as Type, x is Type"
  },
  {
    "title": "Перетворення між char і int",
    "description": "Можна конвертувати символ у його ASCII-код і навпаки"
  },
  {
    "title": "Перетворення bool у int",
    "description": "bool не конвертується прямо в int — треба використати умовну конструкцію"
  },
  {
    "title": "ToString() для обʼєктів",
    "description": "Метод, який повертає текстове представлення обʼєкта"
  },
  {
    "title": "ToString з форматуванням",
    "description": "Наприклад: число.ToString(\"F2\") → округлення до 2 знаків після крапки"
  },
  {
    "title": "Перетворення float у int",
    "description": "Обрізає десяткову частину; потрібно явно вказати тип"
  },
  {
    "title": "Помилки при перетворенні",
    "description": "FormatException, InvalidCastException, OverflowException — типові проблеми"
  },
  {
    "title": "Приведення користувацьких типів",
    "description": "Можна реалізувати явні або неявні оператори cast у своїх класах"
  },




  {
    "title": "Тип DateTime",
    "description": "Вбудований тип для зберігання дати та часу"
  },
  {
    "title": "Поточна дата і час",
    "description": "DateTime.Now — отримання поточного локального часу"
  },
  {
    "title": "Поточна UTC дата і час",
    "description": "DateTime.UtcNow — отримання часу за Гринвічем"
  },
  {
    "title": "Поточна лише дата",
    "description": "DateTime.Today — поточна дата без часу (00:00:00)"
  },
  {
    "title": "Створення обʼєкта DateTime вручну",
    "description": "new DateTime(2025, 5, 31, 14, 30, 0) — конкретна дата і час"
  },
  {
    "title": "Відображення дати у тексті",
    "description": "Використання ToString() з форматами: \"dd.MM.yyyy\", \"yyyy-MM-dd HH:mm\""
  },
  {
    "title": "Форматоване виведення дати",
    "description": "Наприклад: DateTime.Now.ToString(\"dd/MM/yyyy\")"
  },
  {
    "title": "Парсинг дати з рядка",
    "description": "DateTime.Parse(\"2024-05-01\") або DateTime.TryParse() для безпечного парсингу"
  },
  {
    "title": "Вирахування тривалості (TimeSpan)",
    "description": "Різниця між двома датами повертає TimeSpan"
  },
  {
    "title": "Виведення тривалості (TimeSpan)",
    "description": "timeSpan.Days, .Hours, .Minutes, .TotalSeconds — доступ до частин"
  },
  {
    "title": "Додавання днів, годин, місяців",
    "description": "Методи AddDays(), AddHours(), AddMonths(), AddYears()"
  },
  {
    "title": "Віднімання дати",
    "description": "Використання .Subtract() або просто - між двома датами"
  },
  {
    "title": "Порівняння дат",
    "description": "DateTime1 > DateTime2 — перевірка, яка дата пізніше"
  },
  {
    "title": "DateTime.Kind",
    "description": "Визначає, чи дата локальна, UTC чи невідома"
  },
  {
    "title": "Затримка програми",
    "description": "Thread.Sleep(1000) — пауза на 1 секунду"
  },
  {
    "title": "Вимірювання часу виконання",
    "description": "Stopwatch клас з Start(), Stop(), Elapsed"
  },
  {
    "title": "Конвертація дати в Unix time",
    "description": "DateTimeOffset.ToUnixTimeSeconds() — для роботи з epoch часом"
  },




  {
    "title": "Поняття парсінгу",
    "description": "Парсінг — це процес перетворення тексту в структуровані дані (наприклад, рядка в число)"
  },
  {
    "title": "int.Parse()",
    "description": "Перетворює рядок у ціле число; викликає виняток при неправильному форматі"
  },
  {
    "title": "int.TryParse()",
    "description": "Безпечне перетворення рядка в int без винятків; повертає true або false"
  },
  {
    "title": "double.Parse() і double.TryParse()",
    "description": "Парсинг десяткових чисел, враховує локаль (крапка або кома)"
  },
  {
    "title": "bool.Parse() і bool.TryParse()",
    "description": "Парсить 'true' або 'false' (нечутливо до регістру); може викликати помилку"
  },
  {
    "title": "DateTime.Parse() і DateTime.TryParse()",
    "description": "Парсинг дати з рядка у форматі 'yyyy-MM-dd' або іншому локальному форматі"
  },
  {
    "title": "char.Parse()",
    "description": "Перетворення рядка довжиною 1 у символ"
  },
  {
    "title": "Enum.Parse()",
    "description": "Парсинг рядка в значення перерахування (enum)"
  },
  {
    "title": "Split() для парсингу списків",
    "description": "Розбиття рядка за роздільником (наприклад, комою) для створення масиву"
  },
  {
    "title": "Trim(), Replace(), Substring() перед парсингом",
    "description": "Очищення або підготовка рядка перед розбором"
  },
  {
    "title": "TryParseExact() для дат",
    "description": "Чітка відповідність заданому формату дати (наприклад, 'dd.MM.yyyy')"
  },
  {
    "title": "Обробка помилок при парсингу",
    "description": "Використання TryParse або блоків try-catch для уникнення аварій"
  },
  {
    "title": "Парсинг масиву чисел з рядка",
    "description": "Split() + Select(int.Parse) для створення масиву з введеного рядка"
  },
  {
    "title": "Культура і парсинг чисел",
    "description": "CultureInfo може змінювати символ дробу (крапка/кома)"
  },
  {
    "title": "Загальні помилки парсингу",
    "description": "FormatException, OverflowException, неправильний формат вхідного рядка"
  },





  {
    "title": "Поняття дебагінгу (відлагодження)",
    "description": "Процес виявлення та виправлення помилок у програмі"
  },
  {
    "title": "Точка зупину (breakpoint)",
    "description": "Позначка в коді, на якій програма призупиняє виконання"
  },
  {
    "title": "Крокове виконання (Step Over, Step Into)",
    "description": "Пошагове проходження коду для аналізу його виконання"
  },
  {
    "title": "Перевірка значень змінних",
    "description": "Перегляд поточних значень змінних під час виконання в дебаг-режимі"
  },
  {
    "title": "Автоспостереження (Watch)",
    "description": "Інструмент для постійного відстеження значень певних змінних"
  },
  {
    "title": "Вікно локальних змінних (Locals)",
    "description": "Автоматичне відображення всіх змінних у поточному контексті"
  },
  {
    "title": "Вікно стеку викликів (Call Stack)",
    "description": "Показує шлях викликів методів до поточного місця виконання"
  },
  {
    "title": "Обробка винятків під час дебагу",
    "description": "Відображення місця, де відбулась помилка (exception), і її тип"
  },
  {
    "title": "Інтерактивне виведення (Immediate Window)",
    "description": "Виконання команд і перегляд значень під час паузи в дебагу"
  },
  {
    "title": "Дебаг конфігурація",
    "description": "Режим запуску програми з увімкненими інструментами для налагодження"
  },
  {
    "title": "Різниця між Debug та Release",
    "description": "Debug — для тестування (повільніше, з інструментами); Release — для продуктивного запуску"
  },
  {
    "title": "Журнали (логування) та їх роль у відлагодженні",
    "description": "Запис подій і помилок у консоль або файл для подальшого аналізу"
  },
  {
    "title": "Найпоширеніші помилки, що виявляються під час дебагінгу",
    "description": "NullReferenceException, IndexOutOfRangeException, помилки типів"
  },
  {
    "title": "Тестові дані при дебагінгу",
    "description": "Завдання контрольних вхідних даних для перевірки логіки програми"
  },



  {
    "title": "Цілочисельне ділення",
    "description": "Ділення цілих чисел повертає лише цілу частину результату (5 / 2 = 2)"
  },
  {
    "title": "Дійсне ділення",
    "description": "Якщо хоча б один операнд — тип double або float, результат буде дробовим (5.0 / 2 = 2.5)"
  },
  {
    "title": "Оператор % (остача від ділення)",
    "description": "Повертає залишок від ділення (5 % 2 = 1)"
  },
  {
    "title": "Модуль числа (Math.Abs)",
    "description": "Повертає абсолютне значення (модуль) числа, наприклад: Math.Abs(-5) = 5"
  },
  {
    "title": "Округлення до цілого (Math.Round)",
    "description": "Округлення до найближчого цілого: Math.Round(2.6) = 3"
  },
  {
    "title": "Округлення вниз (Math.Floor)",
    "description": "Округлює число в менший бік: Math.Floor(2.9) = 2"
  },
  {
    "title": "Округлення вгору (Math.Ceiling)",
    "description": "Округлює число в більший бік: Math.Ceiling(2.1) = 3"
  },
  {
    "title": "Піднесення до степеня (Math.Pow)",
    "description": "Math.Pow(2, 3) = 8 — підносить число до заданого степеня"
  },
  {
    "title": "Квадратний корінь (Math.Sqrt)",
    "description": "Math.Sqrt(9) = 3 — обчислює квадратний корінь"
  },
  {
    "title": "Мінімум і максимум (Math.Min, Math.Max)",
    "description": "Повертає менше або більше з двох чисел: Math.Min(3, 5) = 3"
  },
  {
    "title": "Тригонометричні функції (Math.Sin, Math.Cos)",
    "description": "Math.Sin(x) і Math.Cos(x) — обчислюють синус і косинус для заданого кута (в радіанах)"
  },
  {
    "title": "Генерація випадкових чисел (Random)",
    "description": "Клас Random використовується для генерації псевдовипадкових чисел"
  },
  {
    "title": "random.Next()",
    "description": "Повертає випадкове ціле число у заданому діапазоні: random.Next(1, 10)"
  },
  {
    "title": "random.NextDouble()",
    "description": "Повертає випадкове число типу double від 0.0 до 1.0"
  },
  {
    "title": "Переповнення типів",
    "description": "Коли число перевищує діапазон типу (наприклад, byte + 1 = 0), виникає переповнення"
  },
  {
    "title": "Оператор checked",
    "description": "Застосовується для виявлення переповнення і генерації помилки: checked { byte x = 255 + 1; }"
  },
  {
    "title": "Оператор unchecked",
    "description": "Ігнорує переповнення і не викликає помилку (за замовчуванням)"
  },



  {
    "title": "Математична константа π (Pi)",
    "description": "Число Pi (π ≈ 3.14159) — відношення довжини кола до його діаметра. В C#: Math.PI"
  },
  {
    "title": "Використання Math.PI",
    "description": "Math.PI застосовується для розрахунків у геометрії, тригонометрії та фізиці"
  },
  {
    "title": "Математична константа e",
    "description": "Число e (≈ 2.71828) — основа натурального логарифма. В C#: Math.E"
  },
  {
    "title": "Використання Math.E",
    "description": "Math.E застосовується у фінансових обчисленнях, експоненційному зростанні, моделюванні"
  },
  {
    "title": "Поняття логарифма",
    "description": "Логарифм — обернена функція до експоненційної: log_b(x) — степінь, до якого треба піднести b, щоб отримати x"
  },
  {
    "title": "Натуральний логарифм (Math.Log)",
    "description": "Math.Log(x) повертає натуральний логарифм (по основі e)"
  },
  {
    "title": "Логарифм за основою 10 (Math.Log10)",
    "description": "Math.Log10(x) повертає десятковий логарифм (по основі 10)"
  },
  {
    "title": "Експоненційна функція (Math.Exp)",
    "description": "Math.Exp(x) повертає e в степені x — експоненту: e^x"
  },
  {
    "title": "Практичне застосування логарифмів",
    "description": "Логарифми використовують у складних обчисленнях, алгоритмах, фінансах, машинному навчанні"
  },
  {
    "title": "Обробка Math.Log(0) та Math.Log(відʼємне)",
    "description": "Math.Log(0) повертає -Infinity, а Math.Log від відʼємного — NaN (не число)"
  },


  {
    "title": "Що таке структура даних",
    "description": "Спосіб організації та зберігання даних для ефективного доступу та модифікації"
  },
  {
    "title": "Масиви (Array)",
    "description": "Фіксована структура з однаковим типом елементів, оголошується через `type[]`"
  },
  {
    "title": "Динамічний список (List<T>)",
    "description": "Колекція змінної довжини, яка підтримує додавання, видалення і сортування елементів"
  },
  {
    "title": "Ініціалізація List<T>",
    "description": "List<int> numbers = new List<int> {1, 2, 3}; — створення та заповнення списку"
  },
  {
    "title": "Методи List<T>",
    "description": "Add, Remove, Contains, Count, Sort — основні методи роботи зі списком"
  },
  {
    "title": "Черга (Queue<T>)",
    "description": "Структура 'першим прийшов — першим обслужений' (FIFO). Методи: Enqueue, Dequeue"
  },
  {
    "title": "Стек (Stack<T>)",
    "description": "Структура 'останній прийшов — перший обслужений' (LIFO). Методи: Push, Pop, Peek"
  },
  {
    "title": "Словник (Dictionary<TKey, TValue>)",
    "description": "Колекція пар 'ключ-значення'. Швидкий доступ за ключем"
  },
  {
    "title": "Перевірка наявності ключа у Dictionary",
    "description": "Метод ContainsKey дозволяє перевірити, чи існує заданий ключ"
  },
  {
    "title": "Коли використовувати масив, а коли список?",
    "description": "Масив — для фіксованого обсягу, список — для змінної кількості елементів"
  },
  {
    "title": "Чим відрізняється Stack від Queue?",
    "description": "Stack працює за принципом LIFO, Queue — FIFO"
  },
  {
    "title": "Перебір елементів колекцій",
    "description": "foreach використовується для перебору всіх елементів у List, Queue, Stack або Dictionary"
  },
  {
    "title": "Очищення структури даних",
    "description": "List.Clear(), Queue.Clear(), Stack.Clear(), Dictionary.Clear() — видаляють усі елементи"
  },




  {
    "title": "Константи (const)",
    "description": "Змінні, значення яких не змінюється після оголошення. Присвоюється одразу. Приклад: const double Pi = 3.14;"
  },
  {
    "title": "Тільки для читання (readonly)",
    "description": "Змінні, значення яких можна задати лише в конструкторі або при оголошенні. Приклад: readonly int id;"
  },
  {
    "title": "Значення за замовчуванням (default)",
    "description": "Оператор default дозволяє отримати стандартне значення типу: default(int) → 0, default(bool) → false"
  },
  {
    "title": "Неявне оголошення змінної (var)",
    "description": "Тип змінної визначається автоматично компілятором за значенням. var name = \"Test\" → string"
  },
  {
    "title": "Динамічний тип (dynamic)",
    "description": "Тип змінної визначається лише під час виконання. Зручно, але менш безпечно"
  },
  {
    "title": "Отримання типу (typeof)",
    "description": "typeof(string) повертає об’єкт типу Type, що описує тип string"
  },
  {
    "title": "Перелічення (enum)",
    "description": "Тип, який задає набір іменованих констант. Приклад: enum Day { Monday, Tuesday }"
  },
  {
    "title": "Структура (struct)",
    "description": "Створення власних простих типів значення з декількох полів. Приклад: struct Point { int x; int y; }"
  },
  {
    "title": "Простори імен (namespace)",
    "description": "Групування пов’язаних класів. Дозволяє уникати конфліктів назв"
  },
  {
    "title": "Коментарі однорядкові (//)",
    "description": "Коментар, що займає один рядок і починається з //"
  },
  {
    "title": "Коментарі багаторядкові (/* */)",
    "description": "Охоплюють декілька рядків, наприклад: /* коментар */"
  },
  {
    "title": "XML-коментарі (///)",
    "description": "Коментарі для автогенерації документації. /// <summary>Опис функції</summary>"
  },
  {
    "title": "Форматування коду",
    "description": "Охайне розташування відступів, дужок, назв для зручності читання"
  },
  {
    "title": "Стиль назв (casing)",
    "description": "camelCase для змінних і параметрів, PascalCase — для класів і методів"
  },
  {
    "title": "Читабельність коду",
    "description": "Пояснювальні назви змінних, розбиття на функції, коментарі"
  },
  {
    "title": "Автодоповнення в Visual Studio",
    "description": "Підказки IntelliSense дозволяють швидше писати код і уникати помилок"
  },
  {
    "title": "Гарячі клавіші VS / VS Code",
    "description": "F5 — запуск, Ctrl+K+C — коментар, Ctrl+Shift+B — збірка"
  },
  {
    "title": "Налагодження (Debugging)",
    "description": "Використання breakpoint, перегляд змінних, крокове виконання"
  },
  {
    "title": "Формування .exe-файлу",
    "description": "C# компілюється у проміжну мову IL, яка запускається через CLR як .exe"
  },
  {
    "title": "Етапи виконання програми C#",
    "description": "Код → компіляція в IL → JIT-компіляція → виконання .exe"
  },
  {
    "title": "Лінійний пошук у масиві",
    "description": "Поелементна перевірка кожного елемента для пошуку значення"
  },
  {
    "title": "Бінарний пошук",
    "description": "Пошук у відсортованому масиві методом ділення навпіл"
  },
  {
    "title": "Сортування методом обміну (bubble sort)",
    "description": "Простий алгоритм сортування шляхом попарного обміну елементів"
  },
  {
    "title": "Сортування вставками",
    "description": "Вставляння елементів у вже відсортовану частину масиву"
  },


  {
    "title": "Що таке вихідний код",
    "description": "Програмний код, написаний людиною на мові програмування (наприклад, C#), який компілюється у виконуваний файл"
  },
  {
    "title": "Процес компіляції",
    "description": "Перетворення вихідного коду у проміжний байткод (IL) за допомогою компілятора"
  },
  {
    "title": "Формування .exe-файлу",
    "description": "Компільований C# код зберігається у .exe або .dll — це контейнер з IL-кодом"
  },
  {
    "title": "Що таке проміжна мова (IL)",
    "description": "Intermediate Language — код, який створюється після компіляції C# і виконується CLR"
  },
  {
    "title": "Роль CLR (Common Language Runtime)",
    "description": "Віртуальна машина, яка JIT-компілює IL у машинний код і виконує його"
  },
  {
    "title": "Етапи виконання C# програми",
    "description": "Код → компіляція в IL → JIT → машинний код → виконання .exe"
  },
  {
    "title": "Різниця між компіляцією та інтерпретацією",
    "description": "Компіляція — попереднє перетворення всього коду, інтерпретація — построкове виконання"
  },
  {
    "title": "Переваги компіляції",
    "description": "Швидке виконання, виявлення помилок до запуску, генерація виконуваних файлів"
  }













]
