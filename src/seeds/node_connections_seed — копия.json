[
  {
    "from": "Кон'юнкція",
    "to": "Закон де Моргана"
  },
  {
    "from": "Диз'юнкція",
    "to": "Закон де Моргана"
  },
  {
    "from": "Заперечення",
    "to": "Закон де Моргана"
  },
  {
    "from": "Типи даних",
    "to": "Булевий тип"
  },
  {
    "from": "Булевий тип",
    "to": "Операції над булевими значеннями"
  },
  {
    "from": "Булевий тип",
    "to": "Кон'юнкція"
  },
  {
    "from": "Булевий тип",
    "to": "Диз'юнкція"
  },
  {
    "from": "Булевий тип",
    "to": "Заперечення"
  },
  {
    "from": "Цілі типи",
    "to": "Перетворення типів"
  },
  {
    "from": "Булевий тип",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Перетворення bool у int",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Класи",
    "to": "Обʼєкти"
  },
  {
    "from": "Обʼєкти",
    "to": "Методи класу"
  },
  {
    "from": "Методи класу",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Змінні",
    "to": "Оголошення змінних"
  },
  {
    "from": "Оголошення змінних",
    "to": "Типи даних"
  },
  {
    "from": "Типи даних",
    "to": "Цілі типи"
  },
  {
    "from": "Типи даних",
    "to": "Реальні типи"
  },
  {
    "from": "Реальні типи",
    "to": "Операції з числами"
  },
  {
    "from": "Цілі типи",
    "to": "Операції з числами"
  },
  {
    "from": "Методи",
    "to": "Методи класу"
  },
  {
    "from": "Методи класу",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Масиви",
    "to": "Цикли"
  },
  {
    "from": "Цикли",
    "to": "Рекурсія"
  },
  {
    "from": "Рекурсія",
    "to": "Факторіал"
  },
  {
    "from": "Рекурсія",
    "to": "Фібоначчі"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перевизначення методів"
  },
  {
    "from": "Класи",
    "to": "Перевизначення методів"
  },
  {
    "from": "Конструкції розгалуження",
    "to": "Операції порівняння"
  },
  {
    "from": "Операції порівняння",
    "to": "Булевий тип"
  },
  {
    "from": "Оператори",
    "to": "Операції з числами"
  },
  {
    "from": "Оператори",
    "to": "Операції порівняння"
  },
  {
    "from": "BufferedStream",
    "to": "StreamReader"
  },
  {
    "from": "BufferedStream",
    "to": "BinaryReader"
  },
  {
    "from": "BufferedStream",
    "to": "Read/Write байтами"
  },
  {
    "from": "BufferedStream",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "BufferedStream",
    "to": "BinaryWriter"
  },
  {
    "from": "BufferedStream",
    "to": "FileStream"
  },
  {
    "from": "BufferedStream",
    "to": "StreamWriter"
  },
  {
    "from": "BufferedStream",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "BufferedStream",
    "to": "FileNotFoundException"
  },
  {
    "from": "OverflowException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "OverflowException",
    "to": "int.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "catch без параметра"
  },
  {
    "from": "OverflowException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "Блок try"
  },
  {
    "from": "OverflowException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "OverflowException",
    "to": "Блок finally"
  },
  {
    "from": "OverflowException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "OverflowException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "OverflowException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "OverflowException",
    "to": "Блок catch"
  },
  {
    "from": "OverflowException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "OverflowException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Boxing",
    "to": "int.TryParse()"
  },
  {
    "from": "Boxing",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Boxing",
    "to": "int.Parse()"
  },
  {
    "from": "Boxing",
    "to": "Перетворення float у int"
  },
  {
    "from": "Boxing",
    "to": "Тип int"
  },
  {
    "from": "Boxing",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Boxing",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Boxing",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Boxing",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Boxing",
    "to": "Тип object"
  },
  {
    "from": "Boxing",
    "to": "Unboxing"
  },
  {
    "from": "Boxing",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "int.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "int.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "int.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "int.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "int.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "int.TryParse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "int.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "int.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "int.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "int.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "int.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "int.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "int.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "int.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "int.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "int.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "int.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "int.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "int.TryParse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "StreamReader",
    "to": "BufferedStream"
  },
  {
    "from": "StreamReader",
    "to": "BinaryReader"
  },
  {
    "from": "StreamReader",
    "to": "Read/Write байтами"
  },
  {
    "from": "StreamReader",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "StreamReader",
    "to": "BinaryWriter"
  },
  {
    "from": "StreamReader",
    "to": "FileStream"
  },
  {
    "from": "StreamReader",
    "to": "StreamWriter"
  },
  {
    "from": "StreamReader",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "StreamReader",
    "to": "FileNotFoundException"
  },
  {
    "from": "InvalidCastException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "InvalidCastException",
    "to": "int.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "catch без параметра"
  },
  {
    "from": "InvalidCastException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "Блок try"
  },
  {
    "from": "InvalidCastException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Блок finally"
  },
  {
    "from": "InvalidCastException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "InvalidCastException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Блок catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "InvalidCastException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "int.Parse()",
    "to": "Тип double"
  },
  {
    "from": "int.Parse()",
    "to": "int.TryParse()"
  },
  {
    "from": "int.Parse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "int.Parse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "int.Parse()",
    "to": "Немінливість string"
  },
  {
    "from": "int.Parse()",
    "to": "Тип DateTime"
  },
  {
    "from": "int.Parse()",
    "to": "Тип int"
  },
  {
    "from": "int.Parse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "int.Parse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "int.Parse()",
    "to": "StringBuilder"
  },
  {
    "from": "int.Parse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "int.Parse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "int.Parse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "int.Parse()",
    "to": "Тип string"
  },
  {
    "from": "int.Parse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "int.Parse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "int.Parse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "int.Parse()",
    "to": "Метод Substring()"
  },
  {
    "from": "int.Parse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "int.Parse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "int.Parse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "int.Parse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "int.Parse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "int.Parse()",
    "to": "Тип даних string"
  },
  {
    "from": "MemoryStream",
    "to": "BufferedStream"
  },
  {
    "from": "MemoryStream",
    "to": "StreamReader"
  },
  {
    "from": "MemoryStream",
    "to": "BinaryReader"
  },
  {
    "from": "MemoryStream",
    "to": "Read/Write байтами"
  },
  {
    "from": "MemoryStream",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "MemoryStream",
    "to": "BinaryWriter"
  },
  {
    "from": "MemoryStream",
    "to": "FileStream"
  },
  {
    "from": "MemoryStream",
    "to": "StreamWriter"
  },
  {
    "from": "MemoryStream",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "MemoryStream",
    "to": "FileNotFoundException"
  },
  {
    "from": "Byte і біт",
    "to": "Встановлення біта"
  },
  {
    "from": "Byte і біт",
    "to": "Побітові операції"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий OR (|)"
  },
  {
    "from": "Byte і біт",
    "to": "Скидання біта"
  },
  {
    "from": "Byte і біт",
    "to": "BinaryReader"
  },
  {
    "from": "Byte і біт",
    "to": "Перевірка біта"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий AND (&)"
  },
  {
    "from": "Byte і біт",
    "to": "Побітові оператори"
  },
  {
    "from": "Byte і біт",
    "to": "BinaryWriter"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий NOT (~)"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий XOR (^)"
  },
  {
    "from": "Byte і біт",
    "to": "Маскування бітів"
  },
  {
    "from": "DivideByZeroException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "int.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "catch без параметра"
  },
  {
    "from": "DivideByZeroException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "Блок try"
  },
  {
    "from": "DivideByZeroException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Блок finally"
  },
  {
    "from": "DivideByZeroException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "DivideByZeroException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Блок catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "int.TryParse()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "BufferedStream"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "StreamReader"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "BinaryReader"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "Read/Write байтами"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "BinaryWriter"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "FileStream"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "StreamWriter"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "FileNotFoundException"
  },
  {
    "from": "FormatException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "FormatException",
    "to": "int.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "catch без параметра"
  },
  {
    "from": "FormatException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "Блок try"
  },
  {
    "from": "FormatException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "FormatException",
    "to": "Блок finally"
  },
  {
    "from": "FormatException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "FormatException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "FormatException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "FormatException",
    "to": "Блок catch"
  },
  {
    "from": "FormatException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "FormatException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип double"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "int.TryParse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Перетворення між char і int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "int.Parse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Перетворення float у int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Немінливість string"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип DateTime"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "DateTime.Kind"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "StringBuilder"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Перетворення bool у int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип string"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "ToString з форматуванням"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Метод Substring()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "random.NextDouble()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип даних string"
  },
  {
    "from": "StackOverflowException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "StackOverflowException",
    "to": "int.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "catch без параметра"
  },
  {
    "from": "StackOverflowException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "Блок try"
  },
  {
    "from": "StackOverflowException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Блок finally"
  },
  {
    "from": "StackOverflowException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "StackOverflowException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Блок catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "StackOverflowException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "FileStream",
    "to": "BufferedStream"
  },
  {
    "from": "FileStream",
    "to": "StreamReader"
  },
  {
    "from": "FileStream",
    "to": "BinaryReader"
  },
  {
    "from": "FileStream",
    "to": "Read/Write байтами"
  },
  {
    "from": "FileStream",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "FileStream",
    "to": "BinaryWriter"
  },
  {
    "from": "FileStream",
    "to": "StreamWriter"
  },
  {
    "from": "FileStream",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "FileStream",
    "to": "FileNotFoundException"
  },
  {
    "from": "FileStream",
    "to": "MemoryStream"
  },
  {
    "from": "FileStream",
    "to": "Потік (Stream)"
  },
  {
    "from": "FileStream",
    "to": "IOException"
  },
  {
    "from": "StreamWriter",
    "to": "BufferedStream"
  },
  {
    "from": "StreamWriter",
    "to": "StreamReader"
  },
  {
    "from": "StreamWriter",
    "to": "BinaryReader"
  },
  {
    "from": "StreamWriter",
    "to": "Read/Write байтами"
  },
  {
    "from": "StreamWriter",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "StreamWriter",
    "to": "BinaryWriter"
  },
  {
    "from": "StreamWriter",
    "to": "FileStream"
  },
  {
    "from": "StreamWriter",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "StreamWriter",
    "to": "FileNotFoundException"
  },
  {
    "from": "ArgumentException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "ArgumentException",
    "to": "int.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "catch без параметра"
  },
  {
    "from": "ArgumentException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "Блок try"
  },
  {
    "from": "ArgumentException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "ArgumentException",
    "to": "Блок finally"
  },
  {
    "from": "ArgumentException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "ArgumentException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "ArgumentException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "ArgumentException",
    "to": "Блок catch"
  },
  {
    "from": "ArgumentException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "ArgumentException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Потік (Stream)",
    "to": "BufferedStream"
  },
  {
    "from": "Потік (Stream)",
    "to": "StreamReader"
  },
  {
    "from": "Потік (Stream)",
    "to": "BinaryReader"
  },
  {
    "from": "Потік (Stream)",
    "to": "Read/Write байтами"
  },
  {
    "from": "Потік (Stream)",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "Потік (Stream)",
    "to": "BinaryWriter"
  },
  {
    "from": "Потік (Stream)",
    "to": "FileStream"
  },
  {
    "from": "Потік (Stream)",
    "to": "StreamWriter"
  },
  {
    "from": "Потік (Stream)",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "Потік (Stream)",
    "to": "FileNotFoundException"
  },
  {
    "from": "char.Parse()",
    "to": "Тип double"
  },
  {
    "from": "char.Parse()",
    "to": "int.TryParse()"
  },
  {
    "from": "char.Parse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "char.Parse()",
    "to": "int.Parse()"
  },
  {
    "from": "char.Parse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "char.Parse()",
    "to": "Немінливість string"
  },
  {
    "from": "char.Parse()",
    "to": "Тип DateTime"
  },
  {
    "from": "char.Parse()",
    "to": "Тип int"
  },
  {
    "from": "char.Parse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "char.Parse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "char.Parse()",
    "to": "StringBuilder"
  },
  {
    "from": "char.Parse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "char.Parse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "char.Parse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "char.Parse()",
    "to": "Тип string"
  },
  {
    "from": "char.Parse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "char.Parse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "char.Parse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "char.Parse()",
    "to": "Метод Substring()"
  },
  {
    "from": "char.Parse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "char.Parse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "char.Parse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "char.Parse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "char.Parse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "char.Parse()",
    "to": "Тип даних string"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "int.TryParse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Явне перетворення (explicit cast)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення рядка в число"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення між char і int"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Приклад: перетворення рядка в число"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення float у int"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення типів (type conversion)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення bool у int"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Відмінність struct від class"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Неявне перетворення (implicit cast)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення введеного тексту в число"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення рваного масиву в звичайний"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Тип object"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення типів (casting)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення багатовимірного масиву на рваний"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Явне перетворення (explicit cast)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення рядка в число"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення між char і int"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Приклад: перетворення рядка в число"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення float у int"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення типів (type conversion)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення bool у int"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Відмінність struct від class"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Неявне перетворення (implicit cast)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення введеного тексту в число"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення рваного масиву в звичайний"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Тип object"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення типів (casting)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення багатовимірного масиву на рваний"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "int.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "catch без параметра"
  },
  {
    "from": "OutOfMemoryException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Блок try"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Блок finally"
  },
  {
    "from": "OutOfMemoryException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "OutOfMemoryException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Блок catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "FileNotFoundException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "int.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "catch без параметра"
  },
  {
    "from": "FileNotFoundException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "Блок try"
  },
  {
    "from": "FileNotFoundException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Блок finally"
  },
  {
    "from": "FileNotFoundException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "FileNotFoundException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Блок catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "FileNotFoundException",
    "to": "BufferedStream"
  },
  {
    "from": "FileNotFoundException",
    "to": "StreamReader"
  },
  {
    "from": "FileNotFoundException",
    "to": "MemoryStream"
  },
  {
    "from": "FileNotFoundException",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "FileNotFoundException",
    "to": "FileStream"
  },
  {
    "from": "FileNotFoundException",
    "to": "StreamWriter"
  },
  {
    "from": "FileNotFoundException",
    "to": "Потік (Stream)"
  },
  {
    "from": "FileNotFoundException",
    "to": "IOException"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Явне перетворення (explicit cast)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення рядка в число"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Приклад: перетворення рядка в число"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення float у int"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення типів (type conversion)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Відмінність struct від class"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Неявне перетворення (implicit cast)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення введеного тексту в число"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення рваного масиву в звичайний"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Тип object"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення типів (casting)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення багатовимірного масиву на рваний"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "IOException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "IOException",
    "to": "int.TryParse()"
  },
  {
    "from": "IOException",
    "to": "catch без параметра"
  },
  {
    "from": "IOException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "IOException",
    "to": "Блок try"
  },
  {
    "from": "IOException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "IOException",
    "to": "Блок finally"
  },
  {
    "from": "IOException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "IOException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "IOException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "IOException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "IOException",
    "to": "Блок catch"
  },
  {
    "from": "IOException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "IOException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "IOException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "ArgumentNullException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "int.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "catch без параметра"
  },
  {
    "from": "ArgumentNullException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "Блок try"
  },
  {
    "from": "ArgumentNullException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Блок finally"
  },
  {
    "from": "ArgumentNullException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "ArgumentNullException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Блок catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Перелічення (enum)",
    "to": "int.TryParse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "int.Parse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Перетворення float у int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Тип int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Перелічення (enum)",
    "to": "char.Parse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Перелічення (enum)",
    "to": "ToString з форматуванням"
  },
  {
    "from": "Перелічення (enum)",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Enum.Parse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Unboxing",
    "to": "int.TryParse()"
  },
  {
    "from": "Unboxing",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Unboxing",
    "to": "int.Parse()"
  },
  {
    "from": "Unboxing",
    "to": "Перетворення float у int"
  },
  {
    "from": "Unboxing",
    "to": "Тип int"
  },
  {
    "from": "Unboxing",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Unboxing",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Unboxing",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Unboxing",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Unboxing",
    "to": "Тип object"
  },
  {
    "from": "Unboxing",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "int.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "catch без параметра"
  },
  {
    "from": "Exception — базовий тип",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Блок try"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Блок finally"
  },
  {
    "from": "Exception — базовий тип",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Exception — базовий тип",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Кілька блоків catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Блок catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Оператор throw у catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип double"
  },
  {
    "from": "Enum.Parse()",
    "to": "int.TryParse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Enum.Parse()",
    "to": "int.Parse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "Enum.Parse()",
    "to": "Немінливість string"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип DateTime"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип int"
  },
  {
    "from": "Enum.Parse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "Enum.Parse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "StringBuilder"
  },
  {
    "from": "Enum.Parse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Enum.Parse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "Enum.Parse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип string"
  },
  {
    "from": "Enum.Parse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Enum.Parse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "Enum.Parse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Enum.Parse()",
    "to": "Метод Substring()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Enum.Parse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "Enum.Parse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "Enum.Parse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип даних string"
  },
  {
    "from": "Enum.Parse()",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Enum.Parse()",
    "to": "char.Parse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "int.TryParse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "int.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "catch без параметра"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Блок try"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Блок finally"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Блок catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "NullReferenceException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "NullReferenceException",
    "to": "int.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "catch без параметра"
  },
  {
    "from": "NullReferenceException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "Блок try"
  },
  {
    "from": "NullReferenceException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Блок finally"
  },
  {
    "from": "NullReferenceException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "NullReferenceException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Блок catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "NullReferenceException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "int.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "catch без параметра"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Блок try"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Блок finally"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Кілька блоків catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Блок catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Оператор throw у catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "finally для звільнення ресурсів"
  }
]