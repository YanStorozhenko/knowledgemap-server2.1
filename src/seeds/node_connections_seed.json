[

  {
    "from": "Поняття алгоритму",
    "to": "Команда виконавця"
  },
  {
    "from": "Команда виконавця",
    "to": "Поняття мови програмування"
  },
  {
    "from": "Поняття мови програмування",
    "to": "Види мов програмування"
  },
  {
    "from": "Види мов програмування",
    "to": "Поняття змінної"
  },
  {
    "from": "Оголошення змінної",
    "to": "Ініціалізація змінної"
  },
  {
    "from": "Ініціалізація змінної",
    "to": "Присвоєння значення"
  },
  {
    "from": "Присвоєння значення",
    "to": "Поняття константи"
  },
  {
    "from": "Поняття константи",
    "to": "Тип int"
  },
  {
    "from": "Тип int",
    "to": "Тип char"
  },
  {
    "from": "Тип char",
    "to": "Тип string"
  },
  {
    "from": "Стек памʼяті",
    "to": "Купа памʼяті"
  },
  {
    "from": "Купа памʼяті",
    "to": "Масив як структура даних"
  },
  {
    "from": "Список як структура даних",
    "to": "Стек як структура даних"
  },
  {
    "from": "Стек як структура даних",
    "to": "Черга як структура даних"
  },
  {
    "from": "Черга як структура даних",
    "to": "Словник як структура даних"
  },
  {
    "from": "Словник як структура даних",
    "to": "Множина як структура даних"
  },
  {
    "from": "Множина як структура даних",
    "to": "Алгоритм як послідовність дій"
  },
  {
    "from": "Властивості алгоритму",
    "to": "Лінійний алгоритм"
  },
  {
    "from": "Розгалужений алгоритм",
    "to": "Циклічний алгоритм"
  },
  {
    "from": "Циклічний алгоритм",
    "to": "Комбінований алгоритм"
  },
  {
    "from": "Комбінований алгоритм",
    "to": "Рекурсивний алгоритм"
  },
  {
    "from": "Рекурсивний алгоритм",
    "to": "Ітеративний алгоритм"
  },
  {
    "from": "Ітеративний алгоритм",
    "to": "Детермінований алгоритм"
  },
  {
    "from": "Детермінований алгоритм",
    "to": "Недетермінований алгоритм"
  },
  {
    "from": "Недетермінований алгоритм",
    "to": "Жадібний алгоритм"
  },
  {
    "from": "Розділяй і володарюй",
    "to": "Динамічне програмування"
  },
  {
    "from": "Динамічне програмування",
    "to": "Життєвий цикл алгоритму"
  },
  {
    "from": "Життєвий цикл алгоритму",
    "to": "Умова в алгоритмах"
  },
  {
    "from": "Поняття змінної",
    "to": "Оголошення змінної"
  },
  {
    "from": "Масив як структура даних",
    "to": "Список як структура даних"
  },
  {
    "from": "Лінійний алгоритм",
    "to": "Розгалужений алгоритм"
  },
  {
    "from": "Комбінований алгоритм",
    "to": "Розділяй і володарюй"
  },
  {
    "from": "Детермінований алгоритм",
    "to": "Життєвий цикл алгоритму"
  },


  {
    "from": "Умова в алгоритмах",
    "to": "Оператор if"
  },
  {
    "from": "Оператор if",
    "to": "Оператор else"
  },
  {
    "from": "Оператор else",
    "to": "Оператор else if"
  },
  {
    "from": "Оператор else if",
    "to": "Вкладені умовні оператори"
  },
  {
    "from": "Вкладені умовні оператори",
    "to": "Оператор switch"
  },
  {
    "from": "Оператор switch",
    "to": "Оператори порівняння"
  },
  {
    "from": "Оператори порівняння",
    "to": "Булевий тип даних"
  },
  {
    "from": "Булевий тип даних",
    "to": "Логічний оператор AND (&&)"
  },
  {
    "from": "Логічний оператор AND (&&)",
    "to": "Логічний оператор OR (||)"
  },
  {
    "from": "Логічний оператор OR (||)",
    "to": "Логічний оператор NOT (!)"
  },
  {
    "from": "Логічний оператор NOT (!)",
    "to": "Логічна імплікація"
  },
  {
    "from": "Логічна імплікація",
    "to": "Логічна еквівалентність"
  },
  {
    "from": "Логічна еквівалентність",
    "to": "Таблиця істинності"
  },
  {
    "from": "Таблиця істинності",
    "to": "Закони де Моргана"
  },
  {
    "from": "Закони де Моргана",
    "to": "Складені логічні вирази"
  },
  {
    "from": "Складені логічні вирази",
    "to": "Пріоритет логічних операторів"
  },
  {
    "from": "Пріоритет логічних операторів",
    "to": "Розгалуження в алгоритмах"
  },
  {
    "from": "Розгалуження в алгоритмах",
    "to": "Булева алгебра в програмуванні"
  },
  {
    "from": "Булева алгебра в програмуванні",
    "to": "Зсув вліво (<<)"
  },
  {
    "from": "Зсув вліво (<<)",
    "to": "Зсув вправо (>>)"
  },
  {
    "from": "Зсув вправо (>>)",
    "to": "Поняття циклу"
  },
  {
    "from": "Поняття циклу",
    "to": "Умова циклу"
  },
  {
    "from": "Умова циклу",
    "to": "Цикл for"
  },
  {
    "from": "Цикл for",
    "to": "Цикл while"
  },
  {
    "from": "Цикл while",
    "to": "Цикл do-while"
  },
  {
    "from": "Цикл do-while",
    "to": "Цикл foreach"
  },
  {
    "from": "Цикл foreach",
    "to": "Нескінченний цикл"
  },
  {
    "from": "Нескінченний цикл",
    "to": "Вкладені цикли"
  },
  {
    "from": "Вкладені цикли",
    "to": "Керування циклом — break"
  },
  {
    "from": "Керування циклом — break",
    "to": "Керування циклом — continue"
  },
  {
    "from": "Керування циклом — continue",
    "to": "Індекс циклу"
  },
  {
    "from": "Індекс циклу",
    "to": "Типові помилки в циклах"
  },
  {
    "from": "Типові помилки в циклах",
    "to": "Перебір масиву циклом for"
  },
  {
    "from": "Перебір масиву циклом for",
    "to": "Перебір колекції циклом foreach"
  },
  {
    "from": "Перебір колекції циклом foreach",
    "to": "Цикл з кроком іншим, ніж 1"
  },
  {
    "from": "Цикл з кроком іншим, ніж 1",
    "to": "Цикл із зменшенням лічильника"
  },
  {
    "from": "Поняття рекурсії",
    "to": "Рекурсивна функція"
  },
  {
    "from": "Рекурсивна функція",
    "to": "Базовий випадок рекурсії"
  },
  {
    "from": "Базовий випадок рекурсії",
    "to": "Рекурсивний випадок"
  },
  {
    "from": "Рекурсивний випадок",
    "to": "Нескінченна рекурсія"
  },
  {
    "from": "Нескінченна рекурсія",
    "to": "Стек викликів при рекурсії"
  },
  {
    "from": "Стек викликів при рекурсії",
    "to": "Факторіал як приклад рекурсії"
  },
  {
    "from": "Факторіал як приклад рекурсії",
    "to": "Фібоначчі як приклад рекурсії"
  },
  {
    "from": "Фібоначчі як приклад рекурсії",
    "to": "Переваги рекурсії"
  },
  {
    "from": "Переваги рекурсії",
    "to": "Недоліки рекурсії"
  },
  {
    "from": "Недоліки рекурсії",
    "to": "Рекурсія проти ітерації"
  },
  {
    "from": "Рекурсія проти ітерації",
    "to": "Хвостова рекурсія"
  },
  {
    "from": "Хвостова рекурсія",
    "to": "Оптимізація рекурсії"
  },
  {
    "from": "Оптимізація рекурсії",
    "to": "Задачі, що природно розвʼязуються рекурсією"
  },

  { "from": "Поняття масиву", "to": "Індекс масиву" },
  { "from": "Індекс масиву", "to": "Оголошення масиву" },
  { "from": "Оголошення масиву", "to": "Ініціалізація масиву" },
  { "from": "Ініціалізація масиву", "to": "Доступ до елемента масиву" },
  { "from": "Доступ до елемента масиву", "to": "Зміна елемента масиву" },
  { "from": "Зміна елемента масиву", "to": "Довжина масиву" },
  { "from": "Довжина масиву", "to": "Прохід масиву через for" },
  { "from": "Прохід масиву через for", "to": "Прохід масиву через foreach" },
  { "from": "Прохід масиву через foreach", "to": "Масиви як параметри методу" },
  { "from": "Масиви як параметри методу", "to": "Масиви як результат методу" },
  { "from": "Масиви як результат методу", "to": "Масив рядків" },
  { "from": "Масив рядків", "to": "Масив булевих значень" },
  { "from": "Масив булевих значень", "to": "Багатовимірний масив" },
  { "from": "Багатовимірний масив", "to": "Ступінчастий масив (jagged)" },
  { "from": "Ступінчастий масив (jagged)", "to": "Копіювання масиву" },
  { "from": "Копіювання масиву", "to": "Сортування масиву" },
  { "from": "Сортування масиву", "to": "Пошук в масиві" },
  { "from": "Пошук в масиві", "to": "Масиви та памʼять" },
  { "from": "Масиви та памʼять", "to": "Масив у памʼяті" },
  { "from": "Масив у памʼяті", "to": "Посилання на масив" },
  { "from": "Посилання на масив", "to": "Розмір масиву в памʼяті" },
  { "from": "Розмір масиву в памʼяті", "to": "Багатовимірний масив" },
  { "from": "Багатовимірний масив", "to": "Зберігання багатовимірного масиву" },
  { "from": "Зберігання багатовимірного масиву", "to": "Індексація в багатовимірному масиві" },
  { "from": "Індексація в багатовимірному масиві", "to": "Ступінчастий масив (рваний масив)" },
  { "from": "Ступінчастий масив (рваний масив)", "to": "Оголошення ступінчастого масиву" },
  { "from": "Оголошення ступінчастого масиву", "to": "Різниця між рваним і багатовимірним масивом" },
  { "from": "Різниця між рваним і багатовимірним масивом", "to": "Памʼять рваного масиву" },
  { "from": "Памʼять рваного масиву", "to": "Прохід по багатовимірному масиву" },
  { "from": "Прохід по багатовимірному масиву", "to": "Прохід по рваному масиву" },


  {
    "from": "Поняття адреси в памʼяті",
    "to": "Адресна памʼять"
  },
  {
    "from": "Поняття адреси в памʼяті",
    "to": "Оператор address-of (&)"
  },
  {
    "from": "Оператор address-of (&)",
    "to": "Непряме звернення"
  },
  {
    "from": "Непряме звернення",
    "to": "Оператор dereference (*)"
  },
  {
    "from": "Оператор dereference (*)",
    "to": "Покажчики в C#"
  },
  {
    "from": "Покажчики в C#",
    "to": "Стекова памʼять"
  },
  {
    "from": "Покажчики в C#",
    "to": "Купа (heap)"
  },
  {
    "from": "Стекова памʼять",
    "to": "Розміщення змінних у стеку"
  },
  {
    "from": "Купа (heap)",
    "to": "Розміщення обʼєктів у купі"
  },
  {
    "from": "Купа (heap)",
    "to": "Garbage Collector"
  },
  {
    "from": "Garbage Collector",
    "to": "Витік памʼяті (memory leak)"
  },
  {
    "from": "Купа (heap)",
    "to": "Фрагментація памʼяті"
  },
  {
    "from": "Адресація в масивах",
    "to": "Покажчик на масив"
  },
  {
    "from": "Поняття структури",
    "to": "Struct як тип значення"
  },
  {
    "from": "Поняття структури",
    "to": "Struct не може мати спадкоємців"
  },
  {
    "from": "Поняття структури",
    "to": "Struct і інтерфейси"
  },
  {
    "from": "Struct як тип значення",
    "to": "Struct і значення за замовчуванням"
  },
  {
    "from": "Struct як тип значення",
    "to": "Копіювання структур"
  },
  {
    "from": "Struct як параметр методу",
    "to": "Копіювання структур"
  },
  {
    "from": "Struct і null",
    "to": "Struct як тип значення"
  },


  { "from": "Тип даних", "to": "Тип значення" },
  { "from": "Тип даних", "to": "Тип посилання" },
  { "from": "Тип даних", "to": "Тип dynamic" },
  { "from": "Тип даних", "to": "Тип var" },
  { "from": "Тип значення", "to": "Struct як тип значення" },
  { "from": "Тип значення", "to": "Nullable типи" },
  { "from": "Тип посилання", "to": "Масив як посилальний тип" },
  { "from": "Тип посилання", "to": "Покажчики в C#" },
  { "from": "Struct як тип значення", "to": "Передача за значенням" },
  { "from": "Масив як посилальний тип", "to": "Передача за посиланням" },
  { "from": "Передача за значенням", "to": "Модифікатор in" },
  { "from": "Передача за посиланням", "to": "Модифікатор ref" },
  { "from": "Передача за посиланням", "to": "Модифікатор out" },
  { "from": "Модифікатор ref", "to": "Struct як тип значення" },
  { "from": "Тип var", "to": "Тип значення" },
  { "from": "Тип dynamic", "to": "Тип посилання" },
  { "from": "Тип dynamic", "to": "Nullable типи" },
  { "from": "Покажчики в C#", "to": "Struct як тип значення" },

  { "from": "Поняття функції (методу)", "to": "Оголошення функції" },
  { "from": "Поняття функції (методу)", "to": "Виклик функції" },
  { "from": "Оголошення функції", "to": "Параметри функції" },
  { "from": "Оголошення функції", "to": "Тип повернення функції" },
  { "from": "Оголошення функції", "to": "Функція без повернення (void)" },
  { "from": "Оголошення функції", "to": "Функція з поверненням значення" },
  { "from": "Оголошення функції", "to": "Функція без параметрів" },
  { "from": "Оголошення функції", "to": "Функція з кількома параметрами" },
  { "from": "Параметри функції", "to": "Функція з ref параметром" },
  { "from": "Параметри функції", "to": "Функція з out параметром" },
  { "from": "Параметри функції", "to": "Функція з in параметром" },
  { "from": "Параметри функції", "to": "Функція з параметром за замовчуванням" },
  { "from": "Параметри функції", "to": "Функція з масивом параметрів (params)" },
  { "from": "Виклик функції", "to": "Аргументи функції" },
  { "from": "Виклик функції", "to": "Виклик функції з іншого класу" },
  { "from": "Тип повернення функції", "to": "Повернення масиву з функції" },
  { "from": "Поняття функції (методу)", "to": "Рекурсивна функція" },
  { "from": "Поняття функції (методу)", "to": "Локальна функція" },
  { "from": "Поняття функції (методу)", "to": "Перевантаження функцій" },


  { "from": "Зовнішнє збереження даних", "to": "Що таке файл" },
  { "from": "Що таке файл", "to": "Розширення файлу" },
  { "from": "Що таке файл", "to": "Текстовий файл" },
  { "from": "Що таке файл", "to": "Бінарний файл" },
  { "from": "Текстовий файл", "to": "Формат CSV" },
  { "from": "Текстовий файл", "to": "Формат JSON" },
  { "from": "Текстовий файл", "to": "Формат XML" },
  { "from": "Текстовий файл", "to": "Формат INI" },
  { "from": "Бінарний файл", "to": "Графічні формати файлів" },
  { "from": "Графічні формати файлів", "to": "Формат BMP" },
  { "from": "Формат BMP", "to": "Особливості BMP" },
  { "from": "Графічні формати файлів", "to": "Формат PNG" },
  { "from": "Графічні формати файлів", "to": "Формат JPEG" },
  { "from": "Графічні формати файлів", "to": "Формат GIF" },
  { "from": "Графічні формати файлів", "to": "Формат SVG" },
  { "from": "Зовнішнє збереження даних", "to": "Читання файлу в C#" },
  { "from": "Зовнішнє збереження даних", "to": "Запис у файл у C#" },
  { "from": "Формат JSON", "to": "Серійне збереження обʼєктів у JSON" },
  { "from": "Формат JSON", "to": "Десеріалізація JSON у C#" },
  { "from": "Читання файлу в C#", "to": "Обробка помилок при роботі з файлами" },
  { "from": "Запис у файл у C#", "to": "Обробка помилок при роботі з файлами" },
  { "from": "Обробка помилок при роботі з файлами", "to": "Права доступу до файлу" },
  { "from": "Що таке файл", "to": "Файлова система" },
  { "from": "Що таке файл", "to": "Абсолютний і відносний шлях до файлу" },
  { "from": "Читання файлу в C#", "to": "Використання using при роботі з файлами" },
  { "from": "Запис у файл у C#", "to": "Використання using при роботі з файлами" },




  { "from": "Види потоків у C#", "to": "FileStream" },
  { "from": "Види потоків у C#", "to": "MemoryStream" },
  { "from": "Види потоків у C#", "to": "NetworkStream" },
  { "from": "Види потоків у C#", "to": "BufferedStream" },
  { "from": "Види потоків у C#", "to": "Відкриття потоку" },
  { "from": "Відкриття потоку", "to": "Читання з потоку" },
  { "from": "Відкриття потоку", "to": "Запис у потік" },
  { "from": "Читання з потоку", "to": "Асинхронна робота з потоками" },
  { "from": "Запис у потік", "to": "Асинхронна робота з потоками" },
  { "from": "Читання з потоку", "to": "Position і Seek" },
  { "from": "Запис у потік", "to": "Position і Seek" },
  { "from": "Відкриття потоку", "to": "Буферизація в потоках" },
  { "from": "Буферизація в потоках", "to": "BufferedStream" },
  { "from": "Відкриття потоку", "to": "Потік як вхідний параметр" },
  { "from": "Запис у потік", "to": "Потік як вхідний параметр" },
  { "from": "Читання з потоку", "to": "Потік як вхідний параметр" },
  { "from": "Відкриття потоку", "to": "Потоки і ресурси" },
  { "from": "Потоки і ресурси", "to": "Закриття потоку" },



  { "from": "Введення даних користувачем", "to": "Типове введення у C#" },
  { "from": "Типове введення у C#", "to": "Безпечне введення числа" },
  { "from": "Типове введення у C#", "to": "Зчитування кількох значень з одного рядка" },
  { "from": "Зчитування кількох значень з одного рядка", "to": "Зчитування масиву чисел з рядка" },
  { "from": "Введення даних користувачем", "to": "Читання символів окремо" },
  { "from": "Введення даних користувачем", "to": "Маскування введення (наприклад, паролі)" },
  { "from": "Введення даних користувачем", "to": "Очистка консолі" },
  { "from": "Введення даних користувачем", "to": "Затримка перед закриттям" },
  { "from": "Виведення даних у консоль", "to": "Форматований вивід" },
  { "from": "Форматований вивід", "to": "Виведення чисел з фіксованою точністю" },
  { "from": "Форматований вивід", "to": "Виведення в таблицю" },
  { "from": "Форматований вивід", "to": "Колір тексту в консолі" },
  { "from": "Створення рядка", "to": "Конкатенація рядків" },
  { "from": "Створення рядка", "to": "Інтерполяція рядків" },
  { "from": "Створення рядка", "to": "Методи обробки рядків" },
  { "from": "Методи обробки рядків", "to": "Метод Split()" },
  { "from": "Методи обробки рядків", "to": "Метод Join()" },
  { "from": "Методи обробки рядків", "to": "Перевірка вмісту" },
  { "from": "Методи обробки рядків", "to": "Форматування рядків" },
  { "from": "Методи обробки рядків", "to": "Escape-послідовності" },
  { "from": "Методи обробки рядків", "to": "Рядки з декількома рядками" },
  { "from": "Методи обробки рядків", "to": "Конвертація символів" },
  { "from": "Методи обробки рядків", "to": "Пошук у рядку" },
  { "from": "Пошук у рядку", "to": "Регулярні вирази" },
  { "from": "Регулярні вирази", "to": "Клас Regex у C#" },
  { "from": "Клас Regex у C#", "to": "Метод Regex.IsMatch" },
  { "from": "Клас Regex у C#", "to": "Метод Regex.Match" },
  { "from": "Клас Regex у C#", "to": "Метод Regex.Matches" },
  { "from": "Клас Regex у C#", "to": "Метод Regex.Replace" },
  { "from": "Регулярні вирази", "to": "Метасимвол . (крапка)" },
  { "from": "Регулярні вирази", "to": "Квантифікатори *, +, ?" },
  { "from": "Регулярні вирази", "to": "Фігурні дужки {n,m}" },
  { "from": "Регулярні вирази", "to": "Класи символів [abc]" },
  { "from": "Регулярні вирази", "to": "Діапазони [a-z]" },
  { "from": "Регулярні вирази", "to": "Інверсія класу символів [^0-9]" },
  { "from": "Регулярні вирази", "to": "Префікси \\d, \\w, \\s" },
  { "from": "Регулярні вирази", "to": "Якір ^ і $" },
  { "from": "Регулярні вирази", "to": "Групи ( ... )" },
  { "from": "Регулярні вирази", "to": "Альтернація |" },
  { "from": "Регулярні вирази", "to": "Екранування спеціальних символів" },
  { "from": "Регулярні вирази", "to": "Приклади використання" },
  { "from": "Регулярні вирази", "to": "RegexOptions" },


  { "from": "Система числення", "to": "Десяткова система" },
  { "from": "Система числення", "to": "Двійкова система" },
  { "from": "Система числення", "to": "Шістнадцяткова система" },
  { "from": "Цифри в різних системах", "to": "Двійкова система" },
  { "from": "Цифри в різних системах", "to": "Шістнадцяткова система" },
  { "from": "Переведення з десяткової в двійкову", "to": "Двійкова система" },
  { "from": "Переведення з десяткової у шістнадцяткову", "to": "Шістнадцяткова система" },
  { "from": "Переведення з двійкової в десяткову", "to": "Десяткова система" },
  { "from": "Представлення чисел у памʼяті", "to": "Двійковий код" },
  { "from": "Представлення чисел у памʼяті", "to": "Представлення від’ємних чисел" },
  { "from": "Представлення від’ємних чисел", "to": "Двійковий код" },
  { "from": "Реальні числа і округлення", "to": "Представлення чисел у памʼяті" },
  { "from": "Застосування шістнадцяткової системи", "to": "Шістнадцяткова система" },
  { "from": "Застосування шістнадцяткової системи", "to": "Представлення чисел у памʼяті" },
  { "from": "Вбудовані методи C# для переведення", "to": "Переведення з десяткової у шістнадцяткову" },
  { "from": "Вбудовані методи C# для переведення", "to": "Переведення з десяткової в двійкову" },
  { "from": "Арифметичні оператори", "to": "Оператор % (остача)" },
  { "from": "Арифметичні оператори", "to": "Ділення цілих чисел" },
  { "from": "Арифметичні оператори", "to": "Ділення з плаваючою крапкою" },
  { "from": "Арифметичні оператори", "to": "Порядок виконання операцій" },
  { "from": "Порядок виконання операцій", "to": "Використання дужок у виразах" },
  { "from": "Інкремент і декремент", "to": "Комбіновані оператори +=, -=, *=, /=" },
  { "from": "Автоматичне приведення типів", "to": "Ділення з плаваючою крапкою" },
  { "from": "Автоматичне приведення типів", "to": "Реальні числа і округлення" },
  { "from": "Автоматичне приведення типів", "to": "Представлення чисел у памʼяті" },


  { "from": "Округлення чисел", "to": "Округлення до n знаків" },
  { "from": "Округлення чисел", "to": "Math.Round()" },
  { "from": "Математичні функції", "to": "Math.Round()" },
  { "from": "Математичні функції", "to": "Math.DivRem()" },
  { "from": "Математичні функції", "to": "Округлення чисел" },
  { "from": "Ділення на нуль", "to": "Типи винятків" },
  { "from": "Ділення на нуль", "to": "Обробка винятків у C#" },
  { "from": "Типові джерела винятків", "to": "Ділення на нуль" },
  { "from": "Типові джерела винятків", "to": "Помилки при перетворенні" },
  { "from": "Обробка винятків у C#", "to": "Типи винятків" },
  { "from": "Обробка винятків у C#", "to": "Коли перехоплювати винятки" },
  { "from": "Обробка винятків у C#", "to": "Викидання винятку вручну" },
  { "from": "Обробка винятків у C#", "to": "Логування винятків" },
  { "from": "Типи винятків", "to": "DivideByZeroException" },
  { "from": "Типи винятків", "to": "FormatException" },
  { "from": "Типи винятків", "to": "OverflowException" },
  { "from": "Помилки при перетворенні", "to": "Оператор приведення (тип)значення" },
  { "from": "Помилки при перетворенні", "to": "as і is оператори" },
  { "from": "Оператор приведення (тип)значення", "to": "Порядок виконання при змішаних типах" },
  { "from": "Порядок виконання при змішаних типах", "to": "Вирази з кількома операціями" },
  { "from": "Множення та переповнення", "to": "Обробка винятків у C#" },
  { "from": "Множення та переповнення", "to": "checked" },
  { "from": "Множення та переповнення", "to": "OverflowException" },
  { "from": "Приведення користувацьких типів", "to": "Оператор приведення (тип)значення" },
  { "from": "Приведення користувацьких типів", "to": "as і is оператори" },




  { "from": "Поточна дата і час", "to": "Відображення дати у тексті" },
  { "from": "Поточна UTC дата і час", "to": "Конвертація дати в Unix time" },
  { "from": "Поточна лише дата", "to": "Форматоване виведення дати" },
  { "from": "Відображення дати у тексті", "to": "Форматоване виведення дати" },
  { "from": "Форматоване виведення дати", "to": "Культура і парсинг чисел" },
  { "from": "Парсинг дати з рядка", "to": "Обробка помилок при парсингу" },
  { "from": "Парсинг дати з рядка", "to": "Поняття парсінгу" },
  { "from": "Парсинг дати з рядка", "to": "Загальні помилки парсингу" },
  { "from": "Поняття парсінгу", "to": "Split() для парсингу списків" },
  { "from": "Split() для парсингу списків", "to": "Парсинг масиву чисел з рядка" },
  { "from": "Обробка помилок при парсингу", "to": "Загальні помилки парсингу" },
  { "from": "Загальні помилки парсингу", "to": "FormatException" },
  { "from": "Вирахування тривалості (TimeSpan)", "to": "Виведення тривалості (TimeSpan)" },
  { "from": "Вирахування тривалості (TimeSpan)", "to": "Віднімання дати" },
  { "from": "Вимірювання часу виконання", "to": "Stopwatch" },
  { "from": "Затримка програми", "to": "Вимірювання часу виконання" },
  { "from": "Порівняння дат", "to": "Віднімання дати" },
  { "from": "Додавання днів, годин, місяців", "to": "Віднімання дати" },
  { "from": "Культура і парсинг чисел", "to": "Парсинг дати з рядка" },
  { "from": "Конвертація дати в Unix time", "to": "Поточна UTC дата і час" },



  { "from": "Поняття дебагінгу (відлагодження)", "to": "Дебаг конфігурація" },
  { "from": "Дебаг конфігурація", "to": "Різниця між Debug та Release" },
  { "from": "Поняття дебагінгу (відлагодження)", "to": "Перевірка значень змінних" },
  { "from": "Перевірка значень змінних", "to": "Автоспостереження (Watch)" },
  { "from": "Перевірка значень змінних", "to": "Вікно локальних змінних (Locals)" },
  { "from": "Перевірка значень змінних", "to": "Інтерактивне виведення (Immediate Window)" },
  { "from": "Вікно локальних змінних (Locals)", "to": "Вікно стеку викликів (Call Stack)" },
  { "from": "Обробка винятків під час дебагу", "to": "Найпоширеніші помилки, що виявляються під час дебагінгу" },
  { "from": "Журнали (логування) та їх роль у відлагодженні", "to": "Обробка винятків під час дебагу" },
  { "from": "Журнали (логування) та їх роль у відлагодженні", "to": "Тестові дані при дебагінгу" },
  { "from": "Тестові дані при дебагінгу", "to": "Поняття дебагінгу (відлагодження)" },
  { "from": "Вікно стеку викликів (Call Stack)", "to": "Обробка винятків під час дебагу" },
  { "from": "Інтерактивне виведення (Immediate Window)", "to": "Перевірка значень змінних" },



  { "from": "Цілочисельне ділення", "to": "Оператор % (остача від ділення)" },
  { "from": "Цілочисельне ділення", "to": "Дійсне ділення" },
  { "from": "Дійсне ділення", "to": "Округлення до цілого (Math.Round)" },
  { "from": "Округлення до цілого (Math.Round)", "to": "Округлення вниз (Math.Floor)" },
  { "from": "Округлення до цілого (Math.Round)", "to": "Округлення вгору (Math.Ceiling)" },
  { "from": "Модуль числа (Math.Abs)", "to": "Округлення до цілого (Math.Round)" },
  { "from": "Піднесення до степеня (Math.Pow)", "to": "Квадратний корінь (Math.Sqrt)" },
  { "from": "Піднесення до степеня (Math.Pow)", "to": "Експоненційна функція (Math.Exp)" },
  { "from": "Квадратний корінь (Math.Sqrt)", "to": "Мінімум і максимум (Math.Min, Math.Max)" },
  { "from": "Тригонометричні функції (Math.Sin, Math.Cos)", "to": "Математична константа π (Pi)" },
  { "from": "Математична константа π (Pi)", "to": "Використання Math.PI" },
  { "from": "Математична константа e", "to": "Використання Math.E" },
  { "from": "Використання Math.E", "to": "Експоненційна функція (Math.Exp)" },
  { "from": "Експоненційна функція (Math.Exp)", "to": "Поняття логарифма" },
  { "from": "Поняття логарифма", "to": "Натуральний логарифм (Math.Log)" },
  { "from": "Поняття логарифма", "to": "Логарифм за основою 10 (Math.Log10)" },
  { "from": "Натуральний логарифм (Math.Log)", "to": "Обробка Math.Log(0) та Math.Log(відʼємне)" },
  { "from": "Логарифм за основою 10 (Math.Log10)", "to": "Практичне застосування логарифмів" },
  { "from": "random.Next()", "to": "Генерація випадкових чисел (Random)" },
  { "from": "Цілочисельне ділення", "to": "Переповнення типів" },
  { "from": "Переповнення типів", "to": "Оператор checked" },
  { "from": "Переповнення типів", "to": "Оператор unchecked" },




  { "from": "Що таке структура даних", "to": "Масиви (Array)" },
  { "from": "Що таке структура даних", "to": "Динамічний список (List<T>)" },
  { "from": "Що таке структура даних", "to": "Черга (Queue<T>)" },
  { "from": "Що таке структура даних", "to": "Стек (Stack<T>)" },
  { "from": "Що таке структура даних", "to": "Словник (Dictionary<TKey, TValue>)" },
  { "from": "Масиви (Array)", "to": "Коли використовувати масив, а коли список?" },
  { "from": "Динамічний список (List<T>)", "to": "Методи List<T>" },
  { "from": "Динамічний список (List<T>)", "to": "Ініціалізація List<T>" },
  { "from": "Queue<T>", "to": "Чим відрізняється Stack від Queue?" },
  { "from": "Stack<T>", "to": "Чим відрізняється Stack від Queue?" },
  { "from": "Словник (Dictionary<TKey, TValue>)", "to": "Перевірка наявності ключа у Dictionary" },
  { "from": "Перебір елементів колекцій", "to": "foreach використовується для перебору всіх елементів" },
  { "from": "Очищення структури даних", "to": "List<T>" },
  { "from": "Очищення структури даних", "to": "Queue<T>" },
  { "from": "Очищення структури даних", "to": "Stack<T>" },
  { "from": "Очищення структури даних", "to": "Dictionary<TKey, TValue>" },
  { "from": "Константи (const)", "to": "Типи значення" },
  { "from": "Значення за замовчуванням (default)", "to": "Типи значення" },
  { "from": "Неявне оголошення змінної (var)", "to": "Тип var" },
  { "from": "Динамічний тип (dynamic)", "to": "Тип dynamic" },
  { "from": "Структура (struct)", "to": "Struct як тип значення" },
  { "from": "Простори імен (namespace)", "to": "Отримання типу (typeof)" },
  { "from": "Отримання типу (typeof)", "to": "Тип значення" },







  {
    "from": "Кон'юнкція",
    "to": "Закон де Моргана"
  },
  {
    "from": "Диз'юнкція",
    "to": "Закон де Моргана"
  },
  {
    "from": "Заперечення",
    "to": "Закон де Моргана"
  },
  {
    "from": "Типи даних",
    "to": "Булевий тип"
  },
  {
    "from": "Булевий тип",
    "to": "Операції над булевими значеннями"
  },
  {
    "from": "Булевий тип",
    "to": "Кон'юнкція"
  },
  {
    "from": "Булевий тип",
    "to": "Диз'юнкція"
  },
  {
    "from": "Булевий тип",
    "to": "Заперечення"
  },
  {
    "from": "Цілі типи",
    "to": "Перетворення типів"
  },
  {
    "from": "Булевий тип",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Перетворення bool у int",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Класи",
    "to": "Обʼєкти"
  },
  {
    "from": "Обʼєкти",
    "to": "Методи класу"
  },
  {
    "from": "Методи класу",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Змінні",
    "to": "Оголошення змінних"
  },
  {
    "from": "Оголошення змінних",
    "to": "Типи даних"
  },
  {
    "from": "Типи даних",
    "to": "Цілі типи"
  },
  {
    "from": "Типи даних",
    "to": "Реальні типи"
  },
  {
    "from": "Реальні типи",
    "to": "Операції з числами"
  },
  {
    "from": "Цілі типи",
    "to": "Операції з числами"
  },
  {
    "from": "Методи",
    "to": "Методи класу"
  },
  {
    "from": "Методи класу",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Масиви",
    "to": "Цикли"
  },
  {
    "from": "Цикли",
    "to": "Рекурсія"
  },
  {
    "from": "Рекурсія",
    "to": "Факторіал"
  },
  {
    "from": "Рекурсія",
    "to": "Фібоначчі"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перевизначення методів"
  },
  {
    "from": "Класи",
    "to": "Перевизначення методів"
  },
  {
    "from": "Конструкції розгалуження",
    "to": "Операції порівняння"
  },
  {
    "from": "Операції порівняння",
    "to": "Булевий тип"
  },
  {
    "from": "Оператори",
    "to": "Операції з числами"
  },
  {
    "from": "Оператори",
    "to": "Операції порівняння"
  },
  {
    "from": "BufferedStream",
    "to": "StreamReader"
  },
  {
    "from": "BufferedStream",
    "to": "BinaryReader"
  },
  {
    "from": "BufferedStream",
    "to": "Read/Write байтами"
  },
  {
    "from": "BufferedStream",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "BufferedStream",
    "to": "BinaryWriter"
  },
  {
    "from": "BufferedStream",
    "to": "FileStream"
  },
  {
    "from": "BufferedStream",
    "to": "StreamWriter"
  },
  {
    "from": "BufferedStream",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "BufferedStream",
    "to": "FileNotFoundException"
  },
  {
    "from": "OverflowException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "OverflowException",
    "to": "int.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "catch без параметра"
  },
  {
    "from": "OverflowException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "Блок try"
  },
  {
    "from": "OverflowException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "OverflowException",
    "to": "Блок finally"
  },
  {
    "from": "OverflowException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "OverflowException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "OverflowException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "OverflowException",
    "to": "Блок catch"
  },
  {
    "from": "OverflowException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "OverflowException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "OverflowException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Boxing",
    "to": "int.TryParse()"
  },
  {
    "from": "Boxing",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Boxing",
    "to": "int.Parse()"
  },
  {
    "from": "Boxing",
    "to": "Перетворення float у int"
  },
  {
    "from": "Boxing",
    "to": "Тип int"
  },
  {
    "from": "Boxing",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Boxing",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Boxing",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Boxing",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Boxing",
    "to": "Тип object"
  },
  {
    "from": "Boxing",
    "to": "Unboxing"
  },
  {
    "from": "Boxing",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "int.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "int.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "int.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "int.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "int.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "int.TryParse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "int.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "int.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "int.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "int.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "int.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "int.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "int.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "int.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "int.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "int.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "int.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "int.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "int.TryParse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "int.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "StreamReader",
    "to": "BufferedStream"
  },
  {
    "from": "StreamReader",
    "to": "BinaryReader"
  },
  {
    "from": "StreamReader",
    "to": "Read/Write байтами"
  },
  {
    "from": "StreamReader",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "StreamReader",
    "to": "BinaryWriter"
  },
  {
    "from": "StreamReader",
    "to": "FileStream"
  },
  {
    "from": "StreamReader",
    "to": "StreamWriter"
  },
  {
    "from": "StreamReader",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "StreamReader",
    "to": "FileNotFoundException"
  },
  {
    "from": "InvalidCastException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "InvalidCastException",
    "to": "int.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "catch без параметра"
  },
  {
    "from": "InvalidCastException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "Блок try"
  },
  {
    "from": "InvalidCastException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Блок finally"
  },
  {
    "from": "InvalidCastException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "InvalidCastException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Блок catch"
  },
  {
    "from": "InvalidCastException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "InvalidCastException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "InvalidCastException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "int.Parse()",
    "to": "Тип double"
  },
  {
    "from": "int.Parse()",
    "to": "int.TryParse()"
  },
  {
    "from": "int.Parse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "int.Parse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "int.Parse()",
    "to": "Немінливість string"
  },
  {
    "from": "int.Parse()",
    "to": "Тип DateTime"
  },
  {
    "from": "int.Parse()",
    "to": "Тип int"
  },
  {
    "from": "int.Parse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "int.Parse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "int.Parse()",
    "to": "StringBuilder"
  },
  {
    "from": "int.Parse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "int.Parse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "int.Parse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "int.Parse()",
    "to": "Тип string"
  },
  {
    "from": "int.Parse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "int.Parse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "int.Parse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "int.Parse()",
    "to": "Метод Substring()"
  },
  {
    "from": "int.Parse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "int.Parse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "int.Parse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "int.Parse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "int.Parse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "int.Parse()",
    "to": "Тип даних string"
  },
  {
    "from": "MemoryStream",
    "to": "BufferedStream"
  },
  {
    "from": "MemoryStream",
    "to": "StreamReader"
  },
  {
    "from": "MemoryStream",
    "to": "BinaryReader"
  },
  {
    "from": "MemoryStream",
    "to": "Read/Write байтами"
  },
  {
    "from": "MemoryStream",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "MemoryStream",
    "to": "BinaryWriter"
  },
  {
    "from": "MemoryStream",
    "to": "FileStream"
  },
  {
    "from": "MemoryStream",
    "to": "StreamWriter"
  },
  {
    "from": "MemoryStream",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "MemoryStream",
    "to": "FileNotFoundException"
  },
  {
    "from": "Byte і біт",
    "to": "Встановлення біта"
  },
  {
    "from": "Byte і біт",
    "to": "Побітові операції"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий OR (|)"
  },
  {
    "from": "Byte і біт",
    "to": "Скидання біта"
  },
  {
    "from": "Byte і біт",
    "to": "BinaryReader"
  },
  {
    "from": "Byte і біт",
    "to": "Перевірка біта"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий AND (&)"
  },
  {
    "from": "Byte і біт",
    "to": "Побітові оператори"
  },
  {
    "from": "Byte і біт",
    "to": "BinaryWriter"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий NOT (~)"
  },
  {
    "from": "Byte і біт",
    "to": "Побітовий XOR (^)"
  },
  {
    "from": "Byte і біт",
    "to": "Маскування бітів"
  },
  {
    "from": "DivideByZeroException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "int.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "catch без параметра"
  },
  {
    "from": "DivideByZeroException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "Блок try"
  },
  {
    "from": "DivideByZeroException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Блок finally"
  },
  {
    "from": "DivideByZeroException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "DivideByZeroException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Блок catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "DivideByZeroException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "DivideByZeroException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "int.TryParse()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "double.Parse() і double.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "BufferedStream"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "StreamReader"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "BinaryReader"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "Read/Write байтами"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "BinaryWriter"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "FileStream"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "StreamWriter"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "Flush у StreamWriter",
    "to": "FileNotFoundException"
  },
  {
    "from": "FormatException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "FormatException",
    "to": "int.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "catch без параметра"
  },
  {
    "from": "FormatException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "Блок try"
  },
  {
    "from": "FormatException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "FormatException",
    "to": "Блок finally"
  },
  {
    "from": "FormatException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "FormatException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "FormatException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "FormatException",
    "to": "Блок catch"
  },
  {
    "from": "FormatException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "FormatException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "FormatException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип double"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "int.TryParse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Перетворення між char і int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "int.Parse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Перетворення float у int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Немінливість string"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип DateTime"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "DateTime.Kind"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "StringBuilder"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Перетворення bool у int"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип string"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "ToString з форматуванням"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Метод Substring()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "random.NextDouble()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "TryParseExact() для дат",
    "to": "Тип даних string"
  },
  {
    "from": "StackOverflowException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "StackOverflowException",
    "to": "int.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "catch без параметра"
  },
  {
    "from": "StackOverflowException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "Блок try"
  },
  {
    "from": "StackOverflowException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Блок finally"
  },
  {
    "from": "StackOverflowException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "StackOverflowException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Блок catch"
  },
  {
    "from": "StackOverflowException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "StackOverflowException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "StackOverflowException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "FileStream",
    "to": "BufferedStream"
  },
  {
    "from": "FileStream",
    "to": "StreamReader"
  },
  {
    "from": "FileStream",
    "to": "BinaryReader"
  },
  {
    "from": "FileStream",
    "to": "Read/Write байтами"
  },
  {
    "from": "FileStream",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "FileStream",
    "to": "BinaryWriter"
  },
  {
    "from": "FileStream",
    "to": "StreamWriter"
  },
  {
    "from": "FileStream",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "FileStream",
    "to": "FileNotFoundException"
  },
  {
    "from": "FileStream",
    "to": "MemoryStream"
  },
  {
    "from": "FileStream",
    "to": "Потік (Stream)"
  },
  {
    "from": "FileStream",
    "to": "IOException"
  },
  {
    "from": "StreamWriter",
    "to": "BufferedStream"
  },
  {
    "from": "StreamWriter",
    "to": "StreamReader"
  },
  {
    "from": "StreamWriter",
    "to": "BinaryReader"
  },
  {
    "from": "StreamWriter",
    "to": "Read/Write байтами"
  },
  {
    "from": "StreamWriter",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "StreamWriter",
    "to": "BinaryWriter"
  },
  {
    "from": "StreamWriter",
    "to": "FileStream"
  },
  {
    "from": "StreamWriter",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "StreamWriter",
    "to": "FileNotFoundException"
  },
  {
    "from": "ArgumentException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "ArgumentException",
    "to": "int.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "catch без параметра"
  },
  {
    "from": "ArgumentException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "Блок try"
  },
  {
    "from": "ArgumentException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "ArgumentException",
    "to": "Блок finally"
  },
  {
    "from": "ArgumentException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "ArgumentException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "ArgumentException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "ArgumentException",
    "to": "Блок catch"
  },
  {
    "from": "ArgumentException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "ArgumentException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "ArgumentException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Потік (Stream)",
    "to": "BufferedStream"
  },
  {
    "from": "Потік (Stream)",
    "to": "StreamReader"
  },
  {
    "from": "Потік (Stream)",
    "to": "BinaryReader"
  },
  {
    "from": "Потік (Stream)",
    "to": "Read/Write байтами"
  },
  {
    "from": "Потік (Stream)",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "Потік (Stream)",
    "to": "BinaryWriter"
  },
  {
    "from": "Потік (Stream)",
    "to": "FileStream"
  },
  {
    "from": "Потік (Stream)",
    "to": "StreamWriter"
  },
  {
    "from": "Потік (Stream)",
    "to": "Тільки для читання (readonly)"
  },
  {
    "from": "Потік (Stream)",
    "to": "FileNotFoundException"
  },
  {
    "from": "char.Parse()",
    "to": "Тип double"
  },
  {
    "from": "char.Parse()",
    "to": "int.TryParse()"
  },
  {
    "from": "char.Parse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "char.Parse()",
    "to": "int.Parse()"
  },
  {
    "from": "char.Parse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "char.Parse()",
    "to": "Немінливість string"
  },
  {
    "from": "char.Parse()",
    "to": "Тип DateTime"
  },
  {
    "from": "char.Parse()",
    "to": "Тип int"
  },
  {
    "from": "char.Parse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "char.Parse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "char.Parse()",
    "to": "StringBuilder"
  },
  {
    "from": "char.Parse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "char.Parse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "char.Parse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "char.Parse()",
    "to": "Тип string"
  },
  {
    "from": "char.Parse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "char.Parse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "char.Parse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "char.Parse()",
    "to": "Метод Substring()"
  },
  {
    "from": "char.Parse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "char.Parse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "char.Parse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "char.Parse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "char.Parse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "char.Parse()",
    "to": "Тип даних string"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "int.TryParse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "bool.Parse() і bool.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Явне перетворення (explicit cast)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення рядка в число"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення між char і int"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Приклад: перетворення рядка в число"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення float у int"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення типів (type conversion)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення bool у int"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Відмінність struct від class"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Неявне перетворення (implicit cast)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення введеного тексту в число"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення рваного масиву в звичайний"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Тип object"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення типів (casting)"
  },
  {
    "from": "ToString з форматуванням",
    "to": "Перетворення багатовимірного масиву на рваний"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Явне перетворення (explicit cast)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення рядка в число"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення між char і int"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Приклад: перетворення рядка в число"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення float у int"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення типів (type conversion)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення bool у int"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Відмінність struct від class"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Неявне перетворення (implicit cast)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення введеного тексту в число"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення рваного масиву в звичайний"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Тип object"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення типів (casting)"
  },
  {
    "from": "ToString() для обʼєктів",
    "to": "Перетворення багатовимірного масиву на рваний"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "int.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "catch без параметра"
  },
  {
    "from": "OutOfMemoryException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Блок try"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Блок finally"
  },
  {
    "from": "OutOfMemoryException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "OutOfMemoryException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Блок catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "OutOfMemoryException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "OutOfMemoryException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "FileNotFoundException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "int.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "catch без параметра"
  },
  {
    "from": "FileNotFoundException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "Блок try"
  },
  {
    "from": "FileNotFoundException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Блок finally"
  },
  {
    "from": "FileNotFoundException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "FileNotFoundException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Блок catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "FileNotFoundException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "FileNotFoundException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "FileNotFoundException",
    "to": "BufferedStream"
  },
  {
    "from": "FileNotFoundException",
    "to": "StreamReader"
  },
  {
    "from": "FileNotFoundException",
    "to": "MemoryStream"
  },
  {
    "from": "FileNotFoundException",
    "to": "Flush у StreamWriter"
  },
  {
    "from": "FileNotFoundException",
    "to": "FileStream"
  },
  {
    "from": "FileNotFoundException",
    "to": "StreamWriter"
  },
  {
    "from": "FileNotFoundException",
    "to": "Потік (Stream)"
  },
  {
    "from": "FileNotFoundException",
    "to": "IOException"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Явне перетворення (explicit cast)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення рядка в число"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Приклад: перетворення рядка в число"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення float у int"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення типів (type conversion)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Відмінність struct від class"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Неявне перетворення (implicit cast)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення введеного тексту в число"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення рваного масиву в звичайний"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Тип object"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення типів (casting)"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "Перетворення багатовимірного масиву на рваний"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "Convert.ToInt32(), ToDouble(), ToString()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "IOException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "IOException",
    "to": "int.TryParse()"
  },
  {
    "from": "IOException",
    "to": "catch без параметра"
  },
  {
    "from": "IOException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "IOException",
    "to": "Блок try"
  },
  {
    "from": "IOException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "IOException",
    "to": "Блок finally"
  },
  {
    "from": "IOException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "IOException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "IOException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "IOException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "IOException",
    "to": "Блок catch"
  },
  {
    "from": "IOException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "IOException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "IOException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "ArgumentNullException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "int.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "catch без параметра"
  },
  {
    "from": "ArgumentNullException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "Блок try"
  },
  {
    "from": "ArgumentNullException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Блок finally"
  },
  {
    "from": "ArgumentNullException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "ArgumentNullException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Блок catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "ArgumentNullException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "ArgumentNullException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Перелічення (enum)",
    "to": "int.TryParse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "int.Parse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Перетворення float у int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Тип int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Перелічення (enum)",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Перелічення (enum)",
    "to": "char.Parse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Перелічення (enum)",
    "to": "ToString з форматуванням"
  },
  {
    "from": "Перелічення (enum)",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "Перелічення (enum)",
    "to": "Enum.Parse()"
  },
  {
    "from": "Перелічення (enum)",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Unboxing",
    "to": "int.TryParse()"
  },
  {
    "from": "Unboxing",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Unboxing",
    "to": "int.Parse()"
  },
  {
    "from": "Unboxing",
    "to": "Перетворення float у int"
  },
  {
    "from": "Unboxing",
    "to": "Тип int"
  },
  {
    "from": "Unboxing",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Unboxing",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Unboxing",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Unboxing",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Unboxing",
    "to": "Тип object"
  },
  {
    "from": "Unboxing",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "int.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "catch без параметра"
  },
  {
    "from": "Exception — базовий тип",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Блок try"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Блок finally"
  },
  {
    "from": "Exception — базовий тип",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Exception — базовий тип",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Кілька блоків catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Блок catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "Оператор throw у catch"
  },
  {
    "from": "Exception — базовий тип",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Exception — базовий тип",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип double"
  },
  {
    "from": "Enum.Parse()",
    "to": "int.TryParse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "Enum.Parse()",
    "to": "int.Parse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "Enum.Parse()",
    "to": "Немінливість string"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип DateTime"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип int"
  },
  {
    "from": "Enum.Parse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "Enum.Parse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "StringBuilder"
  },
  {
    "from": "Enum.Parse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "Enum.Parse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "Enum.Parse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип string"
  },
  {
    "from": "Enum.Parse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "Enum.Parse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "Enum.Parse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "Enum.Parse()",
    "to": "Метод Substring()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "Enum.Parse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "Enum.Parse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "Enum.Parse()",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "Тип даних string"
  },
  {
    "from": "Enum.Parse()",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Enum.Parse()",
    "to": "char.Parse()"
  },
  {
    "from": "Enum.Parse()",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип double"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "int.TryParse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Перетворення між char і int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "int.Parse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Перетворення float у int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Немінливість string"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип DateTime"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "DateTime.Kind"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "StringBuilder"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Перетворення bool у int"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Trim(), Replace(), Substring() перед парсингом"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Крокове виконання (Step Over, Step Into)"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип string"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Точка зупину (breakpoint)"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "ToString з форматуванням"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "ToString() для обʼєктів"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Метод Substring()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Convert.ToInt32(), ToDouble(), ToString()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "random.NextDouble()"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Створення обʼєкта DateTime вручну"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Покажчик (pointer)"
  },
  {
    "from": "DateTime.Parse() і DateTime.TryParse()",
    "to": "Тип даних string"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "int.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "catch без параметра"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Блок try"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Блок finally"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Блок catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "IndexOutOfRangeException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "NullReferenceException",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "NullReferenceException",
    "to": "int.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "catch без параметра"
  },
  {
    "from": "NullReferenceException",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "Блок try"
  },
  {
    "from": "NullReferenceException",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Блок finally"
  },
  {
    "from": "NullReferenceException",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "NullReferenceException",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Кілька блоків catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Блок catch"
  },
  {
    "from": "NullReferenceException",
    "to": "Оператор throw у catch"
  },
  {
    "from": "NullReferenceException",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "NullReferenceException",
    "to": "finally для звільнення ресурсів"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Вкладені блоки try-catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "int.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "catch без параметра"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "double.Parse() і double.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Блок try"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Чого не варто робити в catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Блок finally"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "TryParseExact() для дат"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "bool.Parse() і bool.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Небезпечні операції без try-catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Кілька блоків catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Блок catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "Оператор throw у catch"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "DateTime.Parse() і DateTime.TryParse()"
  },
  {
    "from": "Властивості обʼєкта Exception",
    "to": "finally для звільнення ресурсів"
  }
]